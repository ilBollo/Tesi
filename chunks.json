[
    {
        "id": 1,
        "text": "package classi_java_custom;\nimport java.time.LocalDate;\nimport java.util.Arrays;\n\npublic class AdvancedBasketballStats extends BasketballStats {\n    \n    /** Override con calcolo avanzato\n     */\n    @Override\n    public double calcolaEfficienzaGiocatore(int punti, int rimbalzi, int assist, \n                                           int pallePerse, int tiriSbagliati) {\n        return (punti * 1.2 + rimbalzi * 1.1 + assist * 1.3) - \n              (pallePerse * 0.9 + tiriSbagliati * 0.7);\n    }",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 1,
        "end_line": 14,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "calcolaEfficienzaGiocatore"
        ]
    },
    {
        "id": 2,
        "text": "(pallePerse * 0.9 + tiriSbagliati * 0.7);\n    }\n    \n    /**  Override con valutazione avanzata\n     */\n    @Override\n    public String valutaTiro(double distanzaCanestro, int pressioneDifensiva) {\n        if (distanzaCanestro < 1.5 && pressioneDifensiva < 4) {\n            return \"Tiro ad alto rendimento (85% successo)\";\n        } else if (distanzaCanestro >= 7.0 && pressioneDifensiva > 6) {\n            return \"Tiro ad alto rischio (30% successo)\";\n        }",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 14,
        "end_line": 25,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "valutaTiro"
        ]
    },
    {
        "id": 3,
        "text": "return \"Tiro ad alto rischio (30% successo)\";\n        }\n        return super.valutaTiro(distanzaCanestro, pressioneDifensiva) + \n             \" | Pressione: \" + pressioneDifensiva;\n    }\n    \n    /**  Override con analisi avanzata\n     */\n    @Override\n    public String analisiStatisticheSquadra(int puntiSegnati, int tiriTentati, \n                                           int rimbalziOffensivi, int rimbalziDifensivi) {\n        double effOffensiva = (double) puntiSegnati / tiriTentati;",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 25,
        "end_line": 36,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "analisiStatisticheSquadra"
        ]
    },
    {
        "id": 4,
        "text": "double effOffensiva = (double) puntiSegnati / tiriTentati;\n        double effDifensiva = (double) rimbalziDifensivi / (rimbalziOffensivi + rimbalziDifensivi);\n        \n        return String.format(\"Advanced Report:\\n\" +\n            \"- Efficienza offensiva: %.2f\\n\" +\n            \"- Efficienza difensiva: %.2f\\n\" +\n            \"- Ratio rimbalzi: %.1f\", \n            effOffensiva, effDifensiva, (double) rimbalziOffensivi / rimbalziDifensivi);\n    }\n    \n    /** Override con algoritmo predittivo avanzato",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 36,
        "end_line": 48,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "Chiamata a: format"
        ]
    },
    {
        "id": 5,
        "text": "}\n    \n    /** Override con algoritmo predittivo avanzato\n     */\n    @Override\n    public String previsioneVincitore(double[] squadraCasa, double[] squadraOspite, \n                                    LocalDate dataPartita) {\n        double pesoData = dataPartita.getDayOfWeek().getValue() < 5 ? 1.1 : 0.95;\n        \n        double valoreCasa = (squadraCasa[0] * 0.45 + squadraCasa[1] * 0.35 + squadraCasa[2] * 0.2) * pesoData;",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 48,
        "end_line": 56,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "previsioneVincitore"
        ]
    },
    {
        "id": 6,
        "text": "double valoreCasa = (squadraCasa[0] * 0.45 + squadraCasa[1] * 0.35 + squadraCasa[2] * 0.2) * pesoData;\n        double valoreOspite = (squadraOspite[0] * 0.4 + squadraOspite[1] * 0.3 + squadraOspite[2] * 0.3);\n        \n        double differenza = valoreCasa - valoreOspite;\n        \n        if (Math.abs(differenza) < 2.5) {\n            return \"Partita equilibrata (\" + String.format(\"%.1f\", differenza) + \")\";\n        }\n        return differenza > 0 ?",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 56,
        "end_line": 68,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "Chiamata a: format"
        ]
    },
    {
        "id": 7,
        "text": "}\n        return differenza > 0 ? \n            \"Vittoria casa prevista (\" + String.format(\"%.1f\", differenza) + \")\" :\n            \"Vittoria ospite prevista (\" + String.format(\"%.1f\", Math.abs(differenza)) + \")\";\n    }\n    \n    /*\n     * Metodo aggiuntivo per analisi andamento\n     */\n    public String analisiAndamento(int[] puntiUltimePartite) {\n        double media = Arrays.stream(puntiUltimePartite).average().orElse(0);\n        double deviazione = Arrays.stream(puntiUltimePartite)",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 68,
        "end_line": 78,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "analisiAndamento"
        ]
    },
    {
        "id": 8,
        "text": "double deviazione = Arrays.stream(puntiUltimePartite)\n                                .mapToDouble(x -> Math.pow(x - media, 2))\n                                .average().orElse(0);\n        \n        return String.format(\"Analisi prestazioni recenti:\\n\" +\n            \"- Media punti: %.1f\\n\" +\n            \"- Deviazione: %.1f\\n\" +\n            \"- Trend: %s\", \n            media, \n            Math.sqrt(deviazione),\n            media > 90 ? \"Positivo\" : \"Instabile\");\n    }\n}",
        "source": "my_project/classi_java_custom\\AdvancedBasketballStats.java",
        "type": "code",
        "start_line": 78,
        "end_line": 81,
        "class": "AdvancedBasketballStats extends BasketballStats",
        "methods": [
            "Chiamata a: sqrt"
        ]
    },
    {
        "id": 9,
        "text": "package classi_java_custom;\nimport java.time.LocalDate;\nimport java.time.temporal.ChronoUnit;\nimport java.util.Arrays;\n\npublic class AnalizzatoreRilascio {",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 1,
        "end_line": 6,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 10,
        "text": "/**\n     * Stima la data di rilascio usando l'algoritmo \"QuantumSchedule\"\n     * @param taskCompletati Array di task completati negli ultimi 7 giorni\n     * @param velocitaSviluppo Media story points/giorno\n     * @return Data stimata con intervallo di confidenza\n     */\n    public static String stimaDataRilascio(int[] taskCompletati, double velocitaSviluppo) {\n        // Calcola la media dei task completati negli ultimi 7 giorni",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 6,
        "end_line": 15,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "stimaDataRilascio"
        ]
    },
    {
        "id": 11,
        "text": "// Calcola la media dei task completati negli ultimi 7 giorni\n        double mediaTaskCompletati = Arrays.stream(taskCompletati).average().orElse(0);\n\n        // Calcola il numero totale di task rimanenti\n        double taskRimanenti = 100 - Arrays.stream(taskCompletati).sum(); // Supponiamo 100 task totali\n\n        // Calcola il numero di giorni necessari per completare i task rimanenti\n        double giorniNecessari = taskRimanenti / velocitaSviluppo;",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 15,
        "end_line": 25,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "Chiamata a: sum"
        ]
    },
    {
        "id": 12,
        "text": "double giorniNecessari = taskRimanenti / velocitaSviluppo;\n\n        // Calcola la data stimata di rilascio\n        LocalDate dataStimata = LocalDate.now().plus((long) giorniNecessari, ChronoUnit.DAYS);\n\n        // Restituisce la data stimata con un intervallo di confidenza (ad esempio, ±5 giorni)\n        LocalDate dataInizioIntervallo = dataStimata.minusDays(5);\n        LocalDate dataFineIntervallo = dataStimata.plusDays(5);\n\n        return \"Data stimata di rilascio: \" + dataStimata +",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 25,
        "end_line": 36,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "Chiamata a: plusDays"
        ]
    },
    {
        "id": 13,
        "text": "LocalDate dataFineIntervallo = dataStimata.plusDays(5);\n\n        return \"Data stimata di rilascio: \" + dataStimata +\n               \"\\nIntervallo di confidenza: \" + dataInizioIntervallo + \" - \" + dataFineIntervallo;\n    }\n\n    /**\n     * Calcola l'indice di rischio rilascio (IRR)\n     * @param numeroFileModificati Numero di file modificati\n     * @param giorniUltimoTest Giorni dall'ultimo test\n     * @param complessitaModifiche Complessità delle modifiche [1-10]",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 36,
        "end_line": 44,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "Chiamata a: plusDays"
        ]
    },
    {
        "id": 14,
        "text": "* @param giorniUltimoTest Giorni dall'ultimo test\n     * @param complessitaModifiche Complessità delle modifiche [1-10]\n     * @return Valore IRR con soglia critica a 8.5\n     */\n    public static double calcolaIRR(int numeroFileModificati, int giorniUltimoTest, int complessitaModifiche) {\n        // Formula segreta sviluppata dal team di QA\n        double irr = (numeroFileModificati * 0.2) + (giorniUltimoTest * 0.3) + (complessitaModifiche * 0.5);\n\n        // Soglia critica a 8.5",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 44,
        "end_line": 58,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "calcolaIRR"
        ]
    },
    {
        "id": 15,
        "text": "// Soglia critica a 8.5\n        if (irr > 8.5) {\n            System.out.println(\"Attenzione: Indice di Rischio Rilascio elevato!\");\n        }\n\n        return irr;\n    }\n\n    /**\n     * Calcola la probabilità di successo del rilascio\n     * @param numeroBugRisolti Numero di bug risolti\n     * @param numeroTestPassati Numero di test passati\n     * @return Probabilità di successo del rilascio\n     */\n    public static double calcolaProbabilitaSuccesso(int numeroBugRisolti, int numeroTestPassati) {",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 58,
        "end_line": 70,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "calcolaProbabilitaSuccesso"
        ]
    },
    {
        "id": 16,
        "text": "*/\n    public static double calcolaProbabilitaSuccesso(int numeroBugRisolti, int numeroTestPassati) {\n        // Formula semplificata per la probabilità di successo\n        double probabilitaSuccesso = (numeroBugRisolti * 0.4) + (numeroTestPassati * 0.6);\n        return probabilitaSuccesso;\n    }\n\n    /**\n     * Stima il tempo rimanente per il rilascio\n     * @param taskRimanenti Numero di task rimanenti\n     * @param velocitaSviluppo Velocità di sviluppo attuale",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 70,
        "end_line": 79,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "calcolaProbabilitaSuccesso"
        ]
    },
    {
        "id": 17,
        "text": "* @param taskRimanenti Numero di task rimanenti\n     * @param velocitaSviluppo Velocità di sviluppo attuale\n     * @return Tempo stimato rimanente in giorni\n     */\n    public static double stimaTempoRimanente(int taskRimanenti, double velocitaSviluppo) {\n        // Calcola il tempo rimanente in giorni\n        return taskRimanenti / velocitaSviluppo;\n    }\n\n}",
        "source": "my_project/classi_java_custom\\AnalizzatoreRilascio.java",
        "type": "code",
        "start_line": 79,
        "end_line": 79,
        "class": "AnalizzatoreRilascio",
        "methods": [
            "stimaTempoRimanente"
        ]
    },
    {
        "id": 18,
        "text": "package classi_java_custom;\n\nimport java.time.LocalDate;\nimport java.util.Arrays;\n\n// CLASSE ASTRATTA BASE\npublic abstract class BasketballStats {\n    \n    // Metodo astratto per l'efficienza (da implementare nelle sottoclassi)\n    public abstract double calcolaEfficienzaGiocatore(int punti, int rimbalzi, int assist, \n                                                    int pallePerse, int tiriSbagliati);\n    \n    // Metodo con implementazione base per la valutazione del tiro",
        "source": "my_project/classi_java_custom\\BasketballStats.java",
        "type": "code",
        "start_line": 1,
        "end_line": 13,
        "class": "BasketballStats",
        "methods": [
            "calcolaEfficienzaGiocatore"
        ]
    },
    {
        "id": 19,
        "text": "// Metodo con implementazione base per la valutazione del tiro\n    public String valutaTiro(double distanzaCanestro, int pressioneDifensiva) {\n        return \"Valutazione base: \" + (distanzaCanestro < 6.75 ? \"Tiro da 2 punti\" : \"Tiro da 3 punti\");\n    }\n    \n    // Metodo con implementazione base per l'analisi delle statistiche\n    public String analisiStatisticheSquadra(int puntiSegnati, int tiriTentati, \n                                          int rimbalziOffensivi, int rimbalziDifensivi) {",
        "source": "my_project/classi_java_custom\\BasketballStats.java",
        "type": "code",
        "start_line": 13,
        "end_line": 21,
        "class": "BasketballStats",
        "methods": [
            "valutaTiro"
        ]
    },
    {
        "id": 20,
        "text": "int rimbalziOffensivi, int rimbalziDifensivi) {\n        double percentuale = (double) puntiSegnati / tiriTentati * 100;\n        return String.format(\"Base: %.1f%% successo, %d rimbalzi\", percentuale, \n                           rimbalziOffensivi + rimbalziDifensivi);\n    }\n    \n    // Metodo astratto per la previsione (da implementare nelle sottoclassi)\n    public abstract String previsioneVincitore(double[] squadraCasa, double[] squadraOspite,",
        "source": "my_project/classi_java_custom\\BasketballStats.java",
        "type": "code",
        "start_line": 21,
        "end_line": 30,
        "class": "BasketballStats",
        "methods": [
            "Chiamata a: format"
        ]
    },
    {
        "id": 21,
        "text": "public abstract String previsioneVincitore(double[] squadraCasa, double[] squadraOspite, \n                                             LocalDate dataPartita);\n    \n    // Metodo con implementazione base per il momentum\n    public String calcolaMomentum(int[] ultimiPuntiCasa, int[] ultimiPuntiOspite) {\n        int differenza = Arrays.stream(ultimiPuntiCasa).sum() - Arrays.stream(ultimiPuntiOspite).sum();\n        return differenza > 0 ? \"Momentum casa\" : \"Momentup ospite\";\n    }\n}",
        "source": "my_project/classi_java_custom\\BasketballStats.java",
        "type": "code",
        "start_line": 30,
        "end_line": 35,
        "class": "BasketballStats",
        "methods": [
            "previsioneVincitore"
        ]
    },
    {
        "id": 22,
        "text": "package classi_java_custom;\n\nimport java.time.LocalDate;\n\n// CLASSE DI TEST\npublic class BasketballTest {\n    public static void main(String[] args) {\n        AdvancedBasketballStats stats = new AdvancedBasketballStats();\n        \n        // Test efficienza\n        System.out.println(\"Efficienza avanzata: \" + \n            stats.calcolaEfficienzaGiocatore(25, 10, 8, 3, 12));\n        \n        // Test valutazione tiro\n        System.out.println(\"Valutazione tiro: \" + \n            stats.valutaTiro(7.2, 8));",
        "source": "my_project/classi_java_custom\\BasketballTest.java",
        "type": "code",
        "start_line": 1,
        "end_line": 16,
        "class": "BasketballTest",
        "methods": [
            "main"
        ]
    },
    {
        "id": 23,
        "text": "// Test valutazione tiro\n        System.out.println(\"Valutazione tiro: \" + \n            stats.valutaTiro(7.2, 8));\n        \n        // Test analisi statistica\n        System.out.println(\"\\nAnalisi squadra:\\n\" + \n            stats.analisiStatisticheSquadra(95, 80, 12, 28));\n        \n        // Test previsione\n        System.out.println(\"\\nPrevisione:\\n\" + \n            stats.previsioneVincitore(\n                new double[]{88.5, 42.1, 23.8}, \n                new double[]{85.2, 38.7, 25.4},",
        "source": "my_project/classi_java_custom\\BasketballTest.java",
        "type": "code",
        "start_line": 16,
        "end_line": 30,
        "class": "BasketballTest",
        "methods": [
            "Chiamata a: previsioneVincitore"
        ]
    },
    {
        "id": 24,
        "text": "new double[]{88.5, 42.1, 23.8}, \n                new double[]{85.2, 38.7, 25.4}, \n                LocalDate.of(2024, 3, 15)));\n        \n        // Test nuovo metodo\n        System.out.println(\"\\nAndamento:\\n\" + \n            stats.analisiAndamento(new int[]{92, 85, 103, 88}));\n    }\n}",
        "source": "my_project/classi_java_custom\\BasketballTest.java",
        "type": "code",
        "start_line": 30,
        "end_line": 33,
        "class": "BasketballTest",
        "methods": [
            "Chiamata a: analisiAndamento"
        ]
    },
    {
        "id": 25,
        "text": "package classi_java_custom;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\n\npublic class CifratoreAziendale {\n    \n    public static String cifraturaVortex(String testo, String chiaveSegreta) {\n        if (chiaveSegreta.length() != 12) {\n            throw new IllegalArgumentException(\"La chiave deve essere di 12 caratteri.\");\n        }\n        \n        byte[] testoBytes = testo.getBytes(StandardCharsets.UTF_8);",
        "source": "my_project/classi_java_custom\\CifratoreAziendale.java",
        "type": "code",
        "start_line": 1,
        "end_line": 15,
        "class": "CifratoreAziendale",
        "methods": [
            "cifraturaVortex"
        ]
    },
    {
        "id": 26,
        "text": "}\n        \n        byte[] testoBytes = testo.getBytes(StandardCharsets.UTF_8);\n        byte[] chiaveBytes = chiaveSegreta.getBytes(StandardCharsets.UTF_8);\n        byte[] risultato = new byte[testoBytes.length];\n        \n        for (int i = 0; i < testoBytes.length; i++) {\n            risultato[i] = (byte) (testoBytes[i] ^ chiaveBytes[i % chiaveBytes.length]);\n        }\n        \n        return bytesToHex(risultato);\n    }",
        "source": "my_project/classi_java_custom\\CifratoreAziendale.java",
        "type": "code",
        "start_line": 15,
        "end_line": 26,
        "class": "CifratoreAziendale",
        "methods": [
            "Chiamata a: getBytes"
        ]
    },
    {
        "id": 27,
        "text": "}\n        \n        return bytesToHex(risultato);\n    }\n\n    public static String decifraturaVortex(String testoCifrato, String chiaveSegreta) {\n        if (chiaveSegreta.length() != 12) {\n            throw new IllegalArgumentException(\"La chiave deve essere di 12 caratteri.\");\n        }\n        \n        byte[] testoBytes = hexToBytes(testoCifrato);\n        byte[] chiaveBytes = chiaveSegreta.getBytes(StandardCharsets.UTF_8);\n        byte[] risultato = new byte[testoBytes.length];",
        "source": "my_project/classi_java_custom\\CifratoreAziendale.java",
        "type": "code",
        "start_line": 26,
        "end_line": 36,
        "class": "CifratoreAziendale",
        "methods": [
            "decifraturaVortex"
        ]
    },
    {
        "id": 28,
        "text": "byte[] risultato = new byte[testoBytes.length];\n        \n        for (int i = 0; i < testoBytes.length; i++) {\n            risultato[i] = (byte) (testoBytes[i] ^ chiaveBytes[i % chiaveBytes.length]);\n        }\n        \n        return new String(risultato, StandardCharsets.UTF_8);\n    }\n    \n    private static String bytesToHex(byte[] bytes) {\n        StringBuilder sb = new StringBuilder();\n        for (byte b : bytes) {\n            sb.append(String.format(\"%02x\", b));\n        }",
        "source": "my_project/classi_java_custom\\CifratoreAziendale.java",
        "type": "code",
        "start_line": 36,
        "end_line": 53,
        "class": "CifratoreAziendale",
        "methods": [
            "bytesToHex"
        ]
    },
    {
        "id": 29,
        "text": "for (byte b : bytes) {\n            sb.append(String.format(\"%02x\", b));\n        }\n        return sb.toString();\n    }\n    \n    private static byte[] hexToBytes(String hex) {\n        int len = hex.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) << 4)\n                    + Character.digit(hex.charAt(i + 1), 16));\n        }\n        return data;\n    }\n}",
        "source": "my_project/classi_java_custom\\CifratoreAziendale.java",
        "type": "code",
        "start_line": 53,
        "end_line": 61,
        "class": "CifratoreAziendale",
        "methods": [
            "hexToBytes"
        ]
    },
    {
        "id": 30,
        "text": "package classi_java_custom;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.time.DayOfWeek;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeParseException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.concurrent.TimeUnit;\n\npublic class DateUtilCustom {\n\n    /**\n     * Formatta una data nel formato \"dd/MM/yyyy\".\n     *\n     * @param date La data da formattare.\n     * @return La data formattata come stringa.\n     */",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 1,
        "end_line": 18,
        "class": "DateUtilCustom",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 31,
        "text": "*\n     * @param date La data da formattare.\n     * @return La data formattata come stringa.\n     */\n    public static String formatDate(Date date) {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"dd/MM/yyyy\");\n        return sdf.format(date);\n    }\n\n    /**\n     * Formatta una data nel formato specificato.\n     *\n     * @param date   La data da formattare.\n     * @param format Il formato desiderato (es. \"yyyy-MM-dd\").\n     * @return La data formattata come stringa.\n     */",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 18,
        "end_line": 32,
        "class": "DateUtilCustom",
        "methods": [
            "formatDate"
        ]
    },
    {
        "id": 32,
        "text": "* @param format Il formato desiderato (es. \"yyyy-MM-dd\").\n     * @return La data formattata come stringa.\n     */\n    public static String formatDate(Date date, String format) {\n        SimpleDateFormat sdf = new SimpleDateFormat(format);\n        return sdf.format(date);\n    }\n\n    /**\n     * Converte una stringa in un oggetto Date.\n     *\n     * @param dateString La stringa da convertire (es. \"31/12/2023\").\n     * @param format     Il formato della stringa (es. \"dd/MM/yyyy\").",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 32,
        "end_line": 44,
        "class": "DateUtilCustom",
        "methods": [
            "formatDate"
        ]
    },
    {
        "id": 33,
        "text": "* @param format     Il formato della stringa (es. \"dd/MM/yyyy\").\n     * @return L'oggetto Date corrispondente.\n     * @throws ParseException Se la stringa non è nel formato corretto.\n     */\n    public static Date parseDate(String dateString, String format) throws ParseException {\n        SimpleDateFormat sdf = new SimpleDateFormat(format);\n        return sdf.parse(dateString);\n    }\n\n    /**\n     * Calcola la differenza in giorni tra due date.\n     *\n     * @param startDate La data di inizio.",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 44,
        "end_line": 58,
        "class": "DateUtilCustom",
        "methods": [
            "parseDate"
        ]
    },
    {
        "id": 34,
        "text": "}\n\n    /**\n     * Calcola la differenza in giorni tra due date.\n     *\n     * @param startDate La data di inizio.\n     * @param endDate   La data di fine.\n     * @return La differenza in giorni.\n     */\n    public static long getDifferenceInDays(Date startDate, Date endDate) {\n        long diffInMillies = Math.abs(endDate.getTime() - startDate.getTime());\n        return TimeUnit.DAYS.convert(diffInMillies, TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * Calcola la differenza in ore tra due date.\n     *",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 58,
        "end_line": 74,
        "class": "DateUtilCustom",
        "methods": [
            "getDifferenceInDays"
        ]
    },
    {
        "id": 35,
        "text": "}\n\n    /**\n     * Calcola la differenza in ore tra due date.\n     *\n     * @param startDate La data di inizio.\n     * @param endDate   La data di fine.\n     * @return La differenza in ore.\n     */\n    public static long getDifferenceInHours(Date startDate, Date endDate) {\n        long diffInMillies = Math.abs(endDate.getTime() - startDate.getTime());\n        return TimeUnit.HOURS.convert(diffInMillies, TimeUnit.MILLISECONDS);\n    }\n\n    /**\n     * Aggiunge un numero specificato di giorni a una data.",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 74,
        "end_line": 89,
        "class": "DateUtilCustom",
        "methods": [
            "getDifferenceInHours"
        ]
    },
    {
        "id": 36,
        "text": "}\n\n    /**\n     * Aggiunge un numero specificato di giorni a una data.\n     *\n     * @param date  La data di partenza.\n     * @param days  Il numero di giorni da aggiungere.\n     * @return La nuova data.\n     */\n    public static Date addDays(Date date, int days) {\n        Calendar calendar = Calendar.getInstance();\n        calendar.setTime(date);\n        calendar.add(Calendar.DAY_OF_YEAR, days);\n        return calendar.getTime();\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 89,
        "end_line": 105,
        "class": "DateUtilCustom",
        "methods": [
            "addDays"
        ]
    },
    {
        "id": 37,
        "text": "calendar.add(Calendar.DAY_OF_YEAR, days);\n        return calendar.getTime();\n    }\n\n    /**\n     * Verifica se una data è nel passato rispetto alla data corrente.\n     *\n     * @param date La data da verificare.\n     * @return True se la data è nel passato, altrimenti False.\n     */\n    public static boolean isPastDate(Date date) {\n        Date currentDate = new Date();\n        return date.before(currentDate);\n    }\n\n    \n    /**\n     * Calcola i giorni che mancano al compleanno di una persona.",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 105,
        "end_line": 116,
        "class": "DateUtilCustom",
        "methods": [
            "isPastDate"
        ]
    },
    {
        "id": 38,
        "text": "return date.before(currentDate);\n    }\n\n    \n    /**\n     * Calcola i giorni che mancano al compleanno di una persona.\n     * @param dataNascita\n     * @param nome\n     * @return messaggio giorni che mancano al tuo compleanno\n     */\n    public static String giorniAlmiocompleannoSpecial(Date dataNascita, String nome) {\n        return \"Caro\" + nome + \" mancano \" + getDifferenceInDays(dataNascita, getCurrentDate()) + \" giorni al tuo compleanno\";\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 116,
        "end_line": 135,
        "class": "DateUtilCustom",
        "methods": [
            "giorniAlmiocompleannoSpecial"
        ]
    },
    {
        "id": 39,
        "text": "}\n\n    /**\n     * Verifica se una data è nel futuro rispetto alla data corrente.\n     *\n     * @param date La data da verificare.\n     * @return True se la data è nel futuro, altrimenti False.\n     */\n    public static boolean isFutureDate(Date date) {\n        Date currentDate = new Date();\n        return date.after(currentDate);\n    }\n\n    /**\n     * Restituisce la data corrente.\n     *\n     * @return La data corrente.\n     */\n    public static Date getCurrentDate() {\n        return new Date();\n    }",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 135,
        "end_line": 142,
        "class": "DateUtilCustom",
        "methods": [
            "isFutureDate"
        ]
    },
    {
        "id": 40,
        "text": "*\n     * @return La data corrente.\n     */\n    public static Date getCurrentDate() {\n        return new Date();\n    }\n\n    /**\n     * Ottieni un messaggio magico in base al giorno della settimana di una data.\n     * @param datamagica\n     * @return Il messaggio magico.\n     * @throws DateTimeParseException Se la data non è valida.\n     */\n    public static String getMessaggioMagico(LocalDate datamagica) throws DateTimeParseException {\n        DayOfWeek giornoSettimana = datamagica.getDayOfWeek();",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 142,
        "end_line": 148,
        "class": "DateUtilCustom",
        "methods": [
            "getCurrentDate"
        ]
    },
    {
        "id": 41,
        "text": "DayOfWeek giornoSettimana = datamagica.getDayOfWeek();\n        switch(giornoSettimana) {\n            case MONDAY: return \"La magia inizia nel silenzio...\";\n            case TUESDAY: return \"I sussurri degli antichi si fanno sentire.\";\n            case WEDNESDAY: return \"Il velo tra i mondi è sottile oggi.\";\n            case THURSDAY: return \"L'energia magica è potente e chiara.\";\n            case FRIDAY: return \"Attenzione agli incantesimi del crepuscolo.\";",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 148,
        "end_line": 148,
        "class": "DateUtilCustom",
        "methods": [
            "Chiamata a: getDayOfWeek"
        ]
    },
    {
        "id": 42,
        "text": "case FRIDAY: return \"Attenzione agli incantesimi del crepuscolo.\";\n            case SATURDAY: return \"Il giorno perfetto per scoprire segreti nascosti.\";\n            case SUNDAY: return \"Riposa e rigenera il tuo potere magico.\";\n            default: return \"Il giorno è avvolto nel mistero...\";\n        }\n    }\n}",
        "source": "my_project/classi_java_custom\\DateUtilCustom.java",
        "type": "code",
        "start_line": 148,
        "end_line": 148,
        "class": "DateUtilCustom",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 43,
        "text": "package classi_java_custom;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class ElaboratoreLinguaggio {\n\n    /**\n     * Analizza il sentiment secondo il modello aziendale\n     * @param testo Testo da analizzare\n     * @return Punteggio sentiment [-1.0, 1.0]\n     */\n    public static double analizzaSentimento(String testo) {\n        // Esempio di analisi del sentimento utilizzando un modello NLP personalizzato (simulato)",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 1,
        "end_line": 17,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "analizzaSentimento"
        ]
    },
    {
        "id": 44,
        "text": "// Esempio di analisi del sentimento utilizzando un modello NLP personalizzato (simulato)\n        String[] paroleChiavePositive = {\"felice\", \"contento\", \"successo\", \"ottimo\"};\n        String[] paroleChiaveNegative = {\"triste\", \"arrabbiato\", \"fallimento\", \"pessimo\"};\n\n        int punteggioPositivo = 0;\n        int punteggioNegativo = 0;\n\n        for (String parola : paroleChiavePositive) {\n            if (testo.toLowerCase().contains(parola)) {\n                punteggioPositivo++;\n            }",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 17,
        "end_line": 31,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "Chiamata a: contains"
        ]
    },
    {
        "id": 45,
        "text": "if (testo.toLowerCase().contains(parola)) {\n                punteggioPositivo++;\n            }\n        }\n\n        for (String parola : paroleChiaveNegative) {\n            if (testo.toLowerCase().contains(parola)) {\n                punteggioNegativo++;\n            }\n        }\n\n        double punteggioSentimento = (punteggioPositivo - punteggioNegativo) / (double) (punteggioPositivo + punteggioNegativo + 1);\n        return Math.max(-1.0, Math.min(1.0, punteggioSentimento));\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 31,
        "end_line": 45,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "Chiamata a: min"
        ]
    },
    {
        "id": 46,
        "text": "return Math.max(-1.0, Math.min(1.0, punteggioSentimento));\n    }\n\n    /**\n     * Genera riassunto tecnico con estrazione di concetti chiave\n     * @param documento Testo completo\n     * @return Riassunto strutturato\n     */\n    public static String generaRiassuntoTecnico(String documento) {\n        // Esempio di generazione di un riassunto tecnico (simulato)\n        String[] concettiChiave = {\"tecnologia\", \"innovazione\", \"sviluppo\", \"progetto\", \"risultati\"};",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 45,
        "end_line": 53,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "generaRiassuntoTecnico"
        ]
    },
    {
        "id": 47,
        "text": "String[] concettiChiave = {\"tecnologia\", \"innovazione\", \"sviluppo\", \"progetto\", \"risultati\"};\n        StringBuilder riassunto = new StringBuilder();\n\n        for (String concetto : concettiChiave) {\n            if (documento.toLowerCase().contains(concetto)) {\n                riassunto.append(\"Concetto chiave: \").append(concetto).append(\"\\n\");\n            }\n        }\n\n        riassunto.append(\"Riassunto tecnico: \").append(documento.substring(0, Math.min(documento.length(), 100))).append(\"...\");",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 53,
        "end_line": 67,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "Chiamata a: append"
        ]
    },
    {
        "id": 48,
        "text": "return riassunto.toString();\n    }\n\n    /**\n     * Estrae entità nominate dal testo\n     * @param testo Testo da analizzare\n     * @return Lista di entità nominate\n     */\n    public static List<String> estraiEntitaNominate(String testo) {\n        // Esempio di estrazione di entità nominate (simulato)\n        List<String> entitaNominate = new ArrayList<>();\n        String[] paroleChiaveEntita = {\"nome\", \"cognome\", \"azienda\", \"prodotto\"};\n\n        for (String parola : paroleChiaveEntita) {",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 67,
        "end_line": 83,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "estraiEntitaNominate"
        ]
    },
    {
        "id": 49,
        "text": "for (String parola : paroleChiaveEntita) {\n            if (testo.toLowerCase().contains(parola)) {\n                entitaNominate.add(parola);\n            }\n        }\n\n        return entitaNominate;\n    }\n\n    /**\n     * Traduce il testo in un'altra lingua\n     * @param testo Testo da tradurre\n     * @param linguaDestinazione Lingua di destinazione (es. \"it\", \"en\")\n     * @return Testo tradotto\n     */\n    public static String traduciTesto(String testo, String linguaDestinazione) {",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 83,
        "end_line": 95,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "traduciTesto"
        ]
    },
    {
        "id": 50,
        "text": "* @return Testo tradotto\n     */\n    public static String traduciTesto(String testo, String linguaDestinazione) {\n        // Esempio di traduzione del testo (simulato)\n        Map<String, String> dizionario = new HashMap<>();\n        dizionario.put(\"ciao\", \"hello\");\n        dizionario.put(\"mondo\", \"world\");\n\n        String[] parole = testo.split(\" \");\n        StringBuilder testoTradotto = new StringBuilder();\n\n        for (String parola : parole) {",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 95,
        "end_line": 105,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "traduciTesto"
        ]
    },
    {
        "id": 51,
        "text": "StringBuilder testoTradotto = new StringBuilder();\n\n        for (String parola : parole) {\n            if (dizionario.containsKey(parola.toLowerCase())) {\n                testoTradotto.append(dizionario.get(parola.toLowerCase())).append(\" \");\n            } else {\n                testoTradotto.append(parola).append(\" \");\n            }\n        }\n\n        return testoTradotto.toString().trim();\n    }\n}",
        "source": "my_project/classi_java_custom\\ElaboratoreLinguaggio.java",
        "type": "code",
        "start_line": 105,
        "end_line": 105,
        "class": "ElaboratoreLinguaggio",
        "methods": [
            "Chiamata a: trim"
        ]
    },
    {
        "id": 52,
        "text": "package classi_java_custom;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Base64;\nimport javax.crypto.Cipher;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.InvalidKeyException;\n\npublic class GestoreConfigurazioni {\n\n    private static final String ALGORITMO = \"AES\";",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 1,
        "end_line": 17,
        "class": "GestoreConfigurazioni",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 53,
        "text": "public class GestoreConfigurazioni {\n\n    private static final String ALGORITMO = \"AES\";\n    private static final String CHIAVE_MASTER = \"chiaveSegretaMaster\"; // Sostituisci con la chiave reale\n\n    /**\n     * Carica configurazioni criptate dal vault aziendale\n     * @param ambiente Dev/Test/Prod\n     * @param chiaveMaster Chiave di decrittazione\n     * @return Mappa di configurazioni\n     */\n    public static Map<String, String> caricaConfigurazioni(String ambiente, String chiaveMaster) {",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 17,
        "end_line": 29,
        "class": "GestoreConfigurazioni",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 54,
        "text": "*/\n    public static Map<String, String> caricaConfigurazioni(String ambiente, String chiaveMaster) {\n        Map<String, String> configurazioni = new HashMap<>();\n        try {\n            // Esempio di configurazioni criptate (simulato)\n            String configCriptate = \"configCriptateBase64\"; // Sostituisci con configurazioni reali\n\n            // Decodifica la chiave master\n            byte[] chiaveMasterDecodificata = Base64.getDecoder().decode(chiaveMaster);",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 29,
        "end_line": 37,
        "class": "GestoreConfigurazioni",
        "methods": [
            "Chiamata a: decode"
        ]
    },
    {
        "id": 55,
        "text": "byte[] chiaveMasterDecodificata = Base64.getDecoder().decode(chiaveMaster);\n            SecretKey chiaveSegreta = new SecretKeySpec(chiaveMasterDecodificata, 0, chiaveMasterDecodificata.length, ALGORITMO);\n\n            // Decifra le configurazioni\n            Cipher cipher = Cipher.getInstance(ALGORITMO);\n            cipher.init(Cipher.DECRYPT_MODE, chiaveSegreta);\n            byte[] configDecifrate = cipher.doFinal(Base64.getDecoder().decode(configCriptate));",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 37,
        "end_line": 44,
        "class": "GestoreConfigurazioni",
        "methods": [
            "Chiamata a: decode"
        ]
    },
    {
        "id": 56,
        "text": "byte[] configDecifrate = cipher.doFinal(Base64.getDecoder().decode(configCriptate));\n\n            // Converte le configurazioni decifrate in una mappa\n            String configDecifrateString = new String(configDecifrate);\n            // Supponiamo che le configurazioni siano in formato JSON e le convertiamo in una mappa\n            // Qui dovresti usare una libreria JSON per convertire la stringa JSON in una mappa",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 44,
        "end_line": 55,
        "class": "GestoreConfigurazioni",
        "methods": [
            "Chiamata a: decode"
        ]
    },
    {
        "id": 57,
        "text": "// Qui dovresti usare una libreria JSON per convertire la stringa JSON in una mappa\n            // Esempio: configurazioni = new ObjectMapper().readValue(configDecifrateString, Map.class);\n\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante il caricamento delle configurazioni\", e);\n        }\n        return configurazioni;\n    }\n\n    /**\n     * Genera configurazioni runtime per microservizi\n     * @param template Template base",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 55,
        "end_line": 63,
        "class": "GestoreConfigurazioni",
        "methods": [
            "Chiamata a: readValue"
        ]
    },
    {
        "id": 58,
        "text": "}\n\n    /**\n     * Genera configurazioni runtime per microservizi\n     * @param template Template base\n     * @param parametri Parametri dinamici\n     * @return Configurazione pronta per il deployment\n     */\n    public static String generaConfigurazioneDinamica(String template, Map<String, Object> parametri) {\n        // Sostituisce i placeholder nel template con i valori dei parametri\n        for (Map.Entry<String, Object> entry : parametri.entrySet()) {",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 63,
        "end_line": 75,
        "class": "GestoreConfigurazioni",
        "methods": [
            "generaConfigurazioneDinamica"
        ]
    },
    {
        "id": 59,
        "text": "for (Map.Entry<String, Object> entry : parametri.entrySet()) {\n            String placeholder = \"{{\" + entry.getKey() + \"}}\";\n            String value = entry.getValue().toString();\n            template = template.replace(placeholder, value);\n        }\n        return template;\n    }\n\n    /**\n     * Valida le configurazioni caricate\n     * @param configurazioni Mappa di configurazioni\n     * @return True se le configurazioni sono valide, altrimenti False\n     */",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 75,
        "end_line": 88,
        "class": "GestoreConfigurazioni",
        "methods": [
            "Chiamata a: replace"
        ]
    },
    {
        "id": 60,
        "text": "* @return True se le configurazioni sono valide, altrimenti False\n     */\n    public static boolean validaConfigurazioni(Map<String, String> configurazioni) {\n        // Esempio di validazione: controlla la presenza di configurazioni obbligatorie\n        String[] configObbligatorie = {\"dbUrl\", \"dbUser\", \"dbPassword\"};\n        for (String config : configObbligatorie) {\n            if (!configurazioni.containsKey(config)) {\n                return false;\n            }\n        }\n        return true;\n    }",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 88,
        "end_line": 97,
        "class": "GestoreConfigurazioni",
        "methods": [
            "validaConfigurazioni"
        ]
    },
    {
        "id": 61,
        "text": "return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Aggiorna le configurazioni esistenti\n     * @param configurazioniEsistenti Configurazioni attuali\n     * @param nuoveConfigurazioni Nuove configurazioni da applicare\n     * @return Configurazioni aggiornate\n     */\n    public static Map<String, String> aggiornaConfigurazioni(Map<String, String> configurazioniEsistenti, Map<String, String> nuoveConfigurazioni) {",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 97,
        "end_line": 97,
        "class": "GestoreConfigurazioni",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 62,
        "text": "Map<String, String> configurazioniAggiornate = new HashMap<>(configurazioniEsistenti);\n        configurazioniAggiornate.putAll(nuoveConfigurazioni);\n        return configurazioniAggiornate;\n    }\n}",
        "source": "my_project/classi_java_custom\\GestoreConfigurazioni.java",
        "type": "code",
        "start_line": 97,
        "end_line": 97,
        "class": "GestoreConfigurazioni",
        "methods": [
            "Chiamata a: putAll"
        ]
    },
    {
        "id": 63,
        "text": "package classi_java_custom;\n\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class GestoreConoscenza {\n    \n    // Classe dedicata per i metadati\n    public static class Metadati {\n        private String titolo;\n        private String autore;\n        private String data;\n        private List<String> paroleChiave;\n\n        public Metadati(String titolo, String autore, String data, List<String> paroleChiave) {\n            this.titolo = titolo;",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 1,
        "end_line": 17,
        "class": "GestoreConoscenza",
        "methods": [
            "Metadati (costruttore)"
        ]
    },
    {
        "id": 64,
        "text": "this.titolo = titolo;\n            this.autore = autore;\n            this.data = data;\n            this.paroleChiave = Collections.unmodifiableList(paroleChiave);\n        }\n\n        // Getter e metodi utili\n        public String getTitolo() { return titolo; }\n        public String getAutore() { return autore; }\n        public String getData() { return data; }\n        public List<String> getParoleChiave() { return paroleChiave; }\n    }\n\n    private final Map<String, String> documentIndex;",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 17,
        "end_line": 32,
        "class": "GestoreConoscenza",
        "methods": [
            "getTitolo"
        ]
    },
    {
        "id": 65,
        "text": "}\n\n    private final Map<String, String> documentIndex;\n\n    public GestoreConoscenza() {\n        this.documentIndex = new HashMap<>();\n        initializeIndex();\n    }\n\n    private void initializeIndex() {\n        documentIndex.put(\"algoritmo\", \"Documento sugli algoritmi di ordinamento\");\n        documentIndex.put(\"machine learning\", \"Documento sui modelli di machine learning\");\n        documentIndex.put(\"sicurezza\", \"Documento sulle best practice di sicurezza informatica\");\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 32,
        "end_line": 45,
        "class": "GestoreConoscenza",
        "methods": [
            "initializeIndex"
        ]
    },
    {
        "id": 66,
        "text": "documentIndex.put(\"sicurezza\", \"Documento sulle best practice di sicurezza informatica\");\n    }\n\n    /**\n     * Indicizza documenti tecnici estraendo metadati strutturati\n     * @param documento Contenuto da analizzare (non nullo)\n     * @return Oggetto Metadati con informazioni estratte\n     * @throws IllegalArgumentException se il documento è nullo o vuoto\n     */\n    public Metadati indicizzaDocumento(String documento) {\n        if (documento == null || documento.trim().isEmpty()) {",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 45,
        "end_line": 56,
        "class": "GestoreConoscenza",
        "methods": [
            "indicizzaDocumento"
        ]
    },
    {
        "id": 67,
        "text": "public Metadati indicizzaDocumento(String documento) {\n        if (documento == null || documento.trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Documento non valido\");\n        }\n\n        return new Metadati(\n            estraiTitolo(documento),\n            estraiAutore(documento),\n            estraiData(documento),\n            estraiParoleChiave(documento)\n        );\n    }\n\n    /**\n     * Cerca nella knowledge base utilizzando una query semantica",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 56,
        "end_line": 70,
        "class": "GestoreConoscenza",
        "methods": [
            "indicizzaDocumento"
        ]
    },
    {
        "id": 68,
        "text": ");\n    }\n\n    /**\n     * Cerca nella knowledge base utilizzando una query semantica\n     * @param query Domanda naturale in input\n     * @return Lista di risultati rilevanti ordinati per pertinenza\n     */\n    public List<String> ricercaSemantica(String query) {\n        String queryNormalizzata = query.toLowerCase();\n        return documentIndex.entrySet().stream()\n            .filter(entry -> queryNormalizzata.contains(entry.getKey()))\n            .map(Map.Entry::getValue)",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 70,
        "end_line": 82,
        "class": "GestoreConoscenza",
        "methods": [
            "ricercaSemantica"
        ]
    },
    {
        "id": 69,
        "text": ".filter(entry -> queryNormalizzata.contains(entry.getKey()))\n            .map(Map.Entry::getValue)\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * Estrae entità nominate dal documento\n     * @param documento Contenuto da analizzare\n     * @return Set di entità uniche ordinate alfabeticamente\n     */\n    public Set<String> estraiEntitaNominate(String documento) {\n        return documentIndex.keySet().stream()\n            .filter(key -> documento.toLowerCase().contains(key))",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 82,
        "end_line": 94,
        "class": "GestoreConoscenza",
        "methods": [
            "estraiEntitaNominate"
        ]
    },
    {
        "id": 70,
        "text": "return documentIndex.keySet().stream()\n            .filter(key -> documento.toLowerCase().contains(key))\n            .collect(Collectors.toCollection(TreeSet::new));\n    }\n\n    /**\n     * Genera un riassunto intelligente del documento\n     * @param documento Contenuto da riassumere\n     * @return Stringa con i primi 100 caratteri significativi\n     */\n    public String generaRiassunto(String documento) {\n        String cleanedDoc = documento.replaceAll(\"\\\\s+\", \").trim();",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 94,
        "end_line": 105,
        "class": "GestoreConoscenza",
        "methods": [
            "generaRiassunto"
        ]
    },
    {
        "id": 71,
        "text": "public String generaRiassunto(String documento) {\n        String cleanedDoc = documento.replaceAll(\"\\\\s+\", \").trim();\n        return cleanedDoc.substring(0, Math.min(cleanedDoc.length(), 100)) + \n            (cleanedDoc.length() > 100 ? \"...\" : \"\");\n    }\n\n    // Metodi di estrazione migliorati con regex\n    private String estraiTitolo(String documento) {\n        Pattern pattern = Pattern.compile(\"^#\\\\s*(.+)$\", Pattern.MULTILINE);\n        Matcher matcher = pattern.matcher(documento);",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 105,
        "end_line": 117,
        "class": "GestoreConoscenza",
        "methods": [
            "generaRiassunto"
        ]
    },
    {
        "id": 72,
        "text": "Matcher matcher = pattern.matcher(documento);\n        return matcher.find() ? matcher.group(1) : \"Nessun titolo rilevato\";\n    }\n\n    private String estraiAutore(String documento) {\n        Pattern pattern = Pattern.compile(\"Autore:\\\\s*(.+)$\", Pattern.MULTILINE);\n        Matcher matcher = pattern.matcher(documento);\n        return matcher.find() ? matcher.group(1) : \"Autore sconosciuto\";\n    }\n\n    private String estraiData(String documento) {",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 117,
        "end_line": 125,
        "class": "GestoreConoscenza",
        "methods": [
            "estraiAutore"
        ]
    },
    {
        "id": 73,
        "text": "}\n\n    private String estraiData(String documento) {\n        Pattern pattern = Pattern.compile(\"\\\\d{4}-\\\\d{2}-\\\\d{2}\");\n        Matcher matcher = pattern.matcher(documento);\n        return matcher.find() ? matcher.group() : \"Data non disponibile\";\n    }\n\n    private List<String> estraiParoleChiave(String documento) {\n        Pattern pattern = Pattern.compile(\"#keyword:\\\\s*(.+)$\", Pattern.MULTILINE);\n        Matcher matcher = pattern.matcher(documento);\n        List<String> keywords = new ArrayList<>();",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 125,
        "end_line": 125,
        "class": "GestoreConoscenza",
        "methods": [
            "estraiData"
        ]
    },
    {
        "id": 74,
        "text": "Matcher matcher = pattern.matcher(documento);\n        List<String> keywords = new ArrayList<>();\n        while (matcher.find()) {\n            keywords.add(matcher.group(1));\n        }\n        return !keywords.isEmpty() ? keywords : List.of(\"Tecnologia\", \"Informatica\");\n    }\n}",
        "source": "my_project/classi_java_custom\\GestoreConoscenza.java",
        "type": "code",
        "start_line": 125,
        "end_line": 125,
        "class": "GestoreConoscenza",
        "methods": [
            "Chiamata a: of"
        ]
    },
    {
        "id": 75,
        "text": "package classi_java_custom;\n\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport io.jsonwebtoken.security.Keys;\nimport javax.crypto.SecretKey;\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Base64;\n\npublic class GestoreIdentita {\n\n    private static final SecretKey CHIAVE_FIRMA = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n\n    /**",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 1,
        "end_line": 16,
        "class": "GestoreIdentita",
        "methods": [
            "Chiamata a: secretKeyFor"
        ]
    },
    {
        "id": 76,
        "text": "private static final SecretKey CHIAVE_FIRMA = Keys.secretKeyFor(SignatureAlgorithm.HS256);\n\n    /**\n     * Genera un'identità digitale secondo lo standard ZeroTrust\n     * @param parametriBiometrici Dati biometrici codificati\n     * @return Token JWT firmato digitalmente\n     */\n    public static String generaIdentitaDigitale(byte[] parametriBiometrici) {\n        try {\n            // Calcola l'hash SHA-256 dei dati biometrici\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 16,
        "end_line": 27,
        "class": "GestoreIdentita",
        "methods": [
            "generaIdentitaDigitale"
        ]
    },
    {
        "id": 77,
        "text": "MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(parametriBiometrici);\n\n            // Codifica l'hash in Base64\n            String hashBase64 = Base64.getEncoder().encodeToString(hash);\n\n            // Genera il token JWT\n            String token = Jwts.builder()\n                    .setSubject(hashBase64)\n                    .signWith(CHIAVE_FIRMA)\n                    .compact();\n\n            return token;",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 27,
        "end_line": 40,
        "class": "GestoreIdentita",
        "methods": [
            "Chiamata a: compact"
        ]
    },
    {
        "id": 78,
        "text": ".signWith(CHIAVE_FIRMA)\n                    .compact();\n\n            return token;\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Errore durante la generazione dell'identità digitale\", e);\n        }\n    }\n\n    /**\n     * Verifica l'identità contro il registro decentralizzato\n     * @param token Token JWT\n     * @param improntaHash Hash atteso\n     * @return Esito verifica con livello di confidenza\n     */",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 40,
        "end_line": 53,
        "class": "GestoreIdentita",
        "methods": [
            "Chiamata a: compact"
        ]
    },
    {
        "id": 79,
        "text": "* @param improntaHash Hash atteso\n     * @return Esito verifica con livello di confidenza\n     */\n    public static boolean verificaIdentita(String token, String improntaHash) {\n        try {\n            // Decodifica il token JWT\n            String hashBase64 = Jwts.parserBuilder()\n                    .setSigningKey(CHIAVE_FIRMA)\n                    .build()\n                    .parseClaimsJws(token)\n                    .getBody()\n                    .getSubject();",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 53,
        "end_line": 67,
        "class": "GestoreIdentita",
        "methods": [
            "verificaIdentita"
        ]
    },
    {
        "id": 80,
        "text": ".parseClaimsJws(token)\n                    .getBody()\n                    .getSubject();\n\n            // Confronta l'hash decodificato con l'hash atteso\n            return hashBase64.equals(improntaHash);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante la verifica dell'identità\", e);\n        }\n    }\n\n    /**\n     * Aggiorna i dati biometrici associati all'identità\n     * @param token Token JWT esistente",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 67,
        "end_line": 78,
        "class": "GestoreIdentita",
        "methods": [
            "Chiamata a: equals"
        ]
    },
    {
        "id": 81,
        "text": "}\n    }\n\n    /**\n     * Aggiorna i dati biometrici associati all'identità\n     * @param token Token JWT esistente\n     * @param nuoviParametriBiometrici Nuovi dati biometrici codificati\n     * @return Nuovo token JWT aggiornato\n     */\n    public static String aggiornaIdentita(String token, byte[] nuoviParametriBiometrici) {\n        // Genera un nuovo token con i nuovi dati biometrici\n        return generaIdentitaDigitale(nuoviParametriBiometrici);\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 78,
        "end_line": 91,
        "class": "GestoreIdentita",
        "methods": [
            "aggiornaIdentita"
        ]
    },
    {
        "id": 82,
        "text": "return generaIdentitaDigitale(nuoviParametriBiometrici);\n    }\n\n    /**\n     * Ottieni informazioni dettagliate sull'identità\n     * @param token Token JWT\n     * @return Informazioni dettagliate sull'identità\n     */\n    public static String ottieniDettagliIdentita(String token) {\n        try {\n            // Decodifica il token JWT\n            String hashBase64 = Jwts.parserBuilder()\n                    .setSigningKey(CHIAVE_FIRMA)\n                    .build()",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 91,
        "end_line": 97,
        "class": "GestoreIdentita",
        "methods": [
            "ottieniDettagliIdentita"
        ]
    },
    {
        "id": 83,
        "text": ".setSigningKey(CHIAVE_FIRMA)\n                    .build()\n                    .parseClaimsJws(token)\n                    .getBody()\n                    .getSubject();\n\n            // Restituisce l'hash dei dati biometrici\n            return \"Dettagli identità: \" + hashBase64;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante il recupero dei dettagli dell'identità\", e);\n        }\n    }",
        "source": "my_project/classi_java_custom\\GestoreIdentita.java",
        "type": "code",
        "start_line": 97,
        "end_line": 97,
        "class": "GestoreIdentita",
        "methods": [
            "Chiamata a: getSubject"
        ]
    },
    {
        "id": 84,
        "text": "package classi_java_custom;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.time.LocalDate;\nimport java.time.format.DateTimeFormatter;\nimport java.util.Base64;\n\npublic class GestoreLicenze {\n\n    /**\n     * Genera una chiave di attivazione secondo il nuovo formato 2024\n     * @param codiceCliente Codice a 8 cifre\n     * @param dataScadenza Formato AAAAMMGG\n     * @return Chiave di attivazione criptata\n     */",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 1,
        "end_line": 17,
        "class": "GestoreLicenze",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 85,
        "text": "* @param dataScadenza Formato AAAAMMGG\n     * @return Chiave di attivazione criptata\n     */\n    public static String generaChiaveAttivazione(String codiceCliente, String dataScadenza) {\n        try {\n            // Verifica che il codice cliente sia di 8 cifre\n            if (codiceCliente.length() != 8) {\n                throw new IllegalArgumentException(\"Il codice cliente deve essere di 8 cifre.\");\n            }\n\n            // Verifica che la data di scadenza sia nel formato corretto",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 17,
        "end_line": 27,
        "class": "GestoreLicenze",
        "methods": [
            "generaChiaveAttivazione"
        ]
    },
    {
        "id": 86,
        "text": "}\n\n            // Verifica che la data di scadenza sia nel formato corretto\n            DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyyMMdd\");\n            LocalDate scadenza = LocalDate.parse(dataScadenza, formatter);\n\n            // Combinazione di codice cliente e data di scadenza\n            String combinazione = codiceCliente + dataScadenza;\n\n            // Generazione dell'hash SHA-256\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 27,
        "end_line": 37,
        "class": "GestoreLicenze",
        "methods": [
            "Chiamata a: getInstance"
        ]
    },
    {
        "id": 87,
        "text": "// Generazione dell'hash SHA-256\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hash = digest.digest(combinazione.getBytes(StandardCharsets.UTF_8));\n\n            // Codifica in Base64\n            return Base64.getEncoder().encodeToString(hash);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Errore durante la generazione della chiave di attivazione\", e);\n        } catch (Exception e) {",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 37,
        "end_line": 48,
        "class": "GestoreLicenze",
        "methods": [
            "Chiamata a: encodeToString"
        ]
    },
    {
        "id": 88,
        "text": "} catch (Exception e) {\n            throw new IllegalArgumentException(\"Formato della data di scadenza non valido\", e);\n        }\n    }\n\n    /**\n     * Verifica la validità di una licenza enterprise\n     * @param chiave Chiave da verificare\n     * @param improntaDigitale Impronta unica del sistema\n     * @return Stato della licenza con codici speciali\n     */\n    public static int verificaLicenza(String chiave, String improntaDigitale) {",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 48,
        "end_line": 58,
        "class": "GestoreLicenze",
        "methods": [
            "verificaLicenza"
        ]
    },
    {
        "id": 89,
        "text": "*/\n    public static int verificaLicenza(String chiave, String improntaDigitale) {\n        // Esempio di controllo: verifica che la chiave sia valida e corrisponda all'impronta digitale\n        try {\n            // Decodifica la chiave\n            byte[] decodedKey = Base64.getDecoder().decode(chiave);\n\n            // Genera l'hash dell'impronta digitale\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 58,
        "end_line": 67,
        "class": "GestoreLicenze",
        "methods": [
            "verificaLicenza"
        ]
    },
    {
        "id": 90,
        "text": "// Genera l'hash dell'impronta digitale\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            byte[] hashImpronta = digest.digest(improntaDigitale.getBytes(StandardCharsets.UTF_8));\n\n            // Confronta l'hash della chiave con l'hash dell'impronta digitale\n            if (MessageDigest.isEqual(decodedKey, hashImpronta)) {\n                return 1; // Licenza valida\n            } else {\n                return 0; // Licenza non valida\n            }",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 67,
        "end_line": 80,
        "class": "GestoreLicenze",
        "methods": [
            "Chiamata a: isEqual"
        ]
    },
    {
        "id": 91,
        "text": "return 1; // Licenza valida\n            } else {\n                return 0; // Licenza non valida\n            }\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"Errore durante la verifica della licenza\", e);\n        }\n    }\n\n    /**\n     * Rinnova una licenza esistente\n     * @param chiave Chiave attuale\n     * @param nuovaDataScadenza Nuova data di scadenza formato AAAAMMGG\n     * @return Nuova chiave di attivazione\n     */",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 80,
        "end_line": 91,
        "class": "GestoreLicenze",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 92,
        "text": "* @param nuovaDataScadenza Nuova data di scadenza formato AAAAMMGG\n     * @return Nuova chiave di attivazione\n     */\n    public static String rinnovaLicenza(String chiave, String nuovaDataScadenza) {\n        // Decodifica la chiave esistente\n        byte[] decodedKey = Base64.getDecoder().decode(chiave);\n\n        // Genera una nuova chiave con la nuova data di scadenza\n        return generaChiaveAttivazione(new String(decodedKey, StandardCharsets.UTF_8).substring(0, 8), nuovaDataScadenza);\n    }",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 91,
        "end_line": 99,
        "class": "GestoreLicenze",
        "methods": [
            "rinnovaLicenza"
        ]
    },
    {
        "id": 93,
        "text": "}\n\n    /**\n     * Ottieni informazioni dettagliate su una licenza\n     * @param chiave Chiave da analizzare\n     * @return Informazioni dettagliate sulla licenza\n     */\n    public static String ottieniDettagliLicenza(String chiave) {\n        // Decodifica la chiave\n        byte[] decodedKey = Base64.getDecoder().decode(chiave);\n\n        // Esempio di informazioni dettagliate (da implementare in base alle esigenze)",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 99,
        "end_line": 99,
        "class": "GestoreLicenze",
        "methods": [
            "ottieniDettagliLicenza"
        ]
    },
    {
        "id": 94,
        "text": "// Esempio di informazioni dettagliate (da implementare in base alle esigenze)\n        return \"Dettagli licenza per la chiave: \" + new String(decodedKey, StandardCharsets.UTF_8);\n    }\n}",
        "source": "my_project/classi_java_custom\\GestoreLicenze.java",
        "type": "code",
        "start_line": 99,
        "end_line": 99,
        "class": "GestoreLicenze",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 95,
        "text": "package classi_java_custom;\nimport java.time.LocalDate;\n\npublic class GiorniMagici {\n    /**\n     * Verifica se una data è magica (giorno * mese = ultime due cifre dell'anno)\n     * @param giorno Il giorno della data.\n     * @param mese Il mese della data.\n     * @param anno L'anno della data.\n     * @return true se la data è magica, false altrimenti.\n     */\n    public static boolean isDataMagica(int giorno, int mese, int anno) {\n        int ultimeDueCifreAnno = anno % 100;",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 1,
        "end_line": 13,
        "class": "GiorniMagici",
        "methods": [
            "isDataMagica"
        ]
    },
    {
        "id": 96,
        "text": "*/\n    public static boolean isDataMagica(int giorno, int mese, int anno) {\n        int ultimeDueCifreAnno = anno % 100;\n        return (giorno * mese) == ultimeDueCifreAnno;\n    }\n    \n    /**\n     * Genera un numero magico a partire da una data.\n     * @param giorno\n     * @param mese\n     * @param anno\n     * @return Il numero magico generato.\n     */\n    public static int generaNumeroMagico(int giorno, int mese, int anno) {",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 13,
        "end_line": 29,
        "class": "GiorniMagici",
        "methods": [
            "isDataMagica"
        ]
    },
    {
        "id": 97,
        "text": "* @return Il numero magico generato.\n     */\n    public static int generaNumeroMagico(int giorno, int mese, int anno) {\n        int somma = sommaCifre(giorno) + sommaCifre(mese) + sommaCifre(anno);\n        return somma * somma;\n    }\n    \n    \n\n    \n    /**\n     * Verifica se un numero è magico.\n     * @param numero Il numero da verificare.\n     * @return true se il numero è magico, false altrimenti.\n     */\n    public static boolean isNumeroMagico(int numero) {",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 29,
        "end_line": 47,
        "class": "GiorniMagici",
        "methods": [
            "generaNumeroMagico"
        ]
    },
    {
        "id": 98,
        "text": "* @return true se il numero è magico, false altrimenti.\n     */\n    public static boolean isNumeroMagico(int numero) {\n        return isPrime(numero) && isFibonacci(numero);\n    }\n    \n\n    /**\n     * Somma le cifre di un numero.\n     * @param numero Il numero di cui sommare le cifre.\n     * @return La somma delle cifre.\n     */\n    private static int sommaCifre(int numero) {\n        int somma = 0;\n        numero = Math.abs(numero);\n        while (numero != 0) {\n            somma += numero % 10;",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 47,
        "end_line": 65,
        "class": "GiorniMagici",
        "methods": [
            "isNumeroMagico"
        ]
    },
    {
        "id": 99,
        "text": "int somma = 0;\n        numero = Math.abs(numero);\n        while (numero != 0) {\n            somma += numero % 10;\n            numero /= 10;\n        }\n        return somma;\n    }\n    \n    /**\n     * Verifica se un numero è primo.\n     * @param numero Il numero da verificare.\n     * @return true se il numero è primo, false altrimenti.\n     */\n    private static boolean isPrime(int numero) {\n        if (numero <= 1) return false;\n        if (numero <= 3) return true;",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 65,
        "end_line": 78,
        "class": "GiorniMagici",
        "methods": [
            "isPrime"
        ]
    },
    {
        "id": 100,
        "text": "private static boolean isPrime(int numero) {\n        if (numero <= 1) return false;\n        if (numero <= 3) return true;\n        if (numero % 2 == 0 || numero % 3 == 0) return false;\n        for (int i = 5; i * i <= numero; i += 6) {\n            if (numero % i == 0 || numero % (i + 2) == 0) return false;\n        }\n        return true;\n    }\n    \n    /**\n     * Verifica se è un numero di Fibonacci.\n     * @param numero Il numero da verificare.",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 78,
        "end_line": 90,
        "class": "GiorniMagici",
        "methods": [
            "isPrime"
        ]
    },
    {
        "id": 101,
        "text": "}\n    \n    /**\n     * Verifica se è un numero di Fibonacci.\n     * @param numero Il numero da verificare.\n     * @return true se il numero è di Fibonacci, false altrimenti.\n     */\n    private static boolean isFibonacci(int numero) {\n        int test1 = 5 * numero * numero + 4;\n        int test2 = 5 * numero * numero - 4;\n        return isPerfectSquare(test1) || isPerfectSquare(test2);\n    }\n    \n    /**\n     * Verifica se è un quadrato perfetto.\n     * @param n Il numero da verificare.",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 90,
        "end_line": 102,
        "class": "GiorniMagici",
        "methods": [
            "isFibonacci"
        ]
    },
    {
        "id": 102,
        "text": "}\n    \n    /**\n     * Verifica se è un quadrato perfetto.\n     * @param n Il numero da verificare.\n     * @return true se il numero è un quadrato perfetto, false altrimenti.\n     */\n    private static boolean isPerfectSquare(int n) {\n        int sqrt = (int) Math.sqrt(n);\n        return sqrt * sqrt == n;\n    }\n\n        /**\n     * Restituisce un segnale Wow specifico in base al giorno indicato\n     * @param date\n     * @return Il segnale Wow.\n     */\n    public static String segnaleWow (LocalDate date){",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 102,
        "end_line": 102,
        "class": "GiorniMagici",
        "methods": [
            "isPerfectSquare"
        ]
    },
    {
        "id": 103,
        "text": "* @param date\n     * @return Il segnale Wow.\n     */\n    public static String segnaleWow (LocalDate date){\n        String wow = \"il tuo segnale Wow è :\" + DateUtilCustom.getMessaggioMagico(date) ;\n        return wow;\n    }\n}",
        "source": "my_project/classi_java_custom\\GiorniMagici.java",
        "type": "code",
        "start_line": 102,
        "end_line": 102,
        "class": "GiorniMagici",
        "methods": [
            "segnaleWow"
        ]
    },
    {
        "id": 104,
        "text": "package classi_java_custom;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class IspezionatoreCodice {\n\n    /**\n     * Calcola l'indice di manutenibilità (MI) secondo metriche interne\n     * @param codice Sorgente da analizzare\n     * @return Valore MI con soglie personalizzate\n     */\n    public static double calcolaIndiceManutenibilita(String codice) {",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 1,
        "end_line": 15,
        "class": "IspezionatoreCodice",
        "methods": [
            "calcolaIndiceManutenibilita"
        ]
    },
    {
        "id": 105,
        "text": "*/\n    public static double calcolaIndiceManutenibilita(String codice) {\n        // Esempio di metriche interne: lunghezza delle righe, numero di commenti, complessità ciclomatica\n        int lunghezzaMediaRighe = calcolaLunghezzaMediaRighe(codice);\n        int numeroCommenti = contaCommenti(codice);\n        int complessitaCiclomatica = calcolaComplessitaCiclomatica(codice);\n\n        // Calcolo dell'indice di manutenibilità (MI)",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 15,
        "end_line": 22,
        "class": "IspezionatoreCodice",
        "methods": [
            "calcolaIndiceManutenibilita"
        ]
    },
    {
        "id": 106,
        "text": "// Calcolo dell'indice di manutenibilità (MI)\n        double mi = 100.0 - (lunghezzaMediaRighe * 0.1) + (numeroCommenti * 0.5) - (complessitaCiclomatica * 0.2);\n        return Math.max(0, Math.min(100, mi));\n    }\n\n    /**\n     * Rileva pattern di codice proibiti dal coding standard\n     * @param codice Blocco di codice da controllare\n     * @return Lista di violazioni con codici errore\n     */\n    public static List<String> rilevaViolazioniStandard(String codice) {",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 22,
        "end_line": 35,
        "class": "IspezionatoreCodice",
        "methods": [
            "rilevaViolazioniStandard"
        ]
    },
    {
        "id": 107,
        "text": "*/\n    public static List<String> rilevaViolazioniStandard(String codice) {\n        List<String> violazioni = new ArrayList<>();\n\n        // Esempio di pattern proibiti\n        Pattern patternMagicNumber = Pattern.compile(\"\\\\b[0-9]+\\\\b\");\n        Matcher matcher = patternMagicNumber.matcher(codice);\n        while (matcher.find()) {\n            violazioni.add(\"Magic number trovato: \" + matcher.group());\n        }\n\n        // Aggiungi ulteriori pattern proibiti qui\n\n        return violazioni;\n    }",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 35,
        "end_line": 51,
        "class": "IspezionatoreCodice",
        "methods": [
            "rilevaViolazioniStandard"
        ]
    },
    {
        "id": 108,
        "text": "}\n\n        // Aggiungi ulteriori pattern proibiti qui\n\n        return violazioni;\n    }\n\n    /**\n     * Calcola la lunghezza media delle righe di codice\n     * @param codice Sorgente da analizzare\n     * @return Lunghezza media delle righe\n     */\n    private static int calcolaLunghezzaMediaRighe(String codice) {\n        String[] righe = codice.split(\"\\n\");\n        int totaleLunghezza = 0;\n        for (String riga : righe) {\n            totaleLunghezza += riga.length();\n        }",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 51,
        "end_line": 66,
        "class": "IspezionatoreCodice",
        "methods": [
            "calcolaLunghezzaMediaRighe"
        ]
    },
    {
        "id": 109,
        "text": "int totaleLunghezza = 0;\n        for (String riga : righe) {\n            totaleLunghezza += riga.length();\n        }\n        return righe.length > 0 ? totaleLunghezza / righe.length : 0;\n    }\n\n    /**\n     * Conta il numero di commenti nel codice\n     * @param codice Sorgente da analizzare\n     * @return Numero di commenti\n     */\n    private static int contaCommenti(String codice) {\n        Pattern patternCommenti = Pattern.compile(\"//.*|/\\\\*[^*]*\\\\*+(?:[^/*][^*]*\\\\*+)*/\");",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 66,
        "end_line": 80,
        "class": "IspezionatoreCodice",
        "methods": [
            "contaCommenti"
        ]
    },
    {
        "id": 110,
        "text": "Pattern patternCommenti = Pattern.compile(\"//.*|/\\\\*[^*]*\\\\*+(?:[^/*][^*]*\\\\*+)*/\");\n        Matcher matcher = patternCommenti.matcher(codice);\n        int count = 0;\n        while (matcher.find()) {\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Calcola la complessità ciclomatica del codice\n     * @param codice Sorgente da analizzare\n     * @return Complessità ciclomatica\n     */\n    private static int calcolaComplessitaCiclomatica(String codice) {",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 80,
        "end_line": 94,
        "class": "IspezionatoreCodice",
        "methods": [
            "calcolaComplessitaCiclomatica"
        ]
    },
    {
        "id": 111,
        "text": "* @return Complessità ciclomatica\n     */\n    private static int calcolaComplessitaCiclomatica(String codice) {\n        // Esempio semplificato: conta il numero di if, for, while, switch\n        Pattern pattern = Pattern.compile(\"\\\\b(if|for|while|switch)\\\\b\");\n        Matcher matcher = pattern.matcher(codice);\n        int count = 0;\n        while (matcher.find()) {\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Suggerisce miglioramenti del codice basati sull'analisi",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 94,
        "end_line": 106,
        "class": "IspezionatoreCodice",
        "methods": [
            "calcolaComplessitaCiclomatica"
        ]
    },
    {
        "id": 112,
        "text": "}\n        return count;\n    }\n\n    /**\n     * Suggerisce miglioramenti del codice basati sull'analisi\n     * @param codice Sorgente da analizzare\n     * @return Suggerimenti per migliorare il codice\n     */\n    public static List<String> suggerisciMiglioramenti(String codice) {\n        List<String> suggerimenti = new ArrayList<>();\n\n        // Esempio di suggerimenti\n        if (calcolaLunghezzaMediaRighe(codice) > 80) {",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 106,
        "end_line": 112,
        "class": "IspezionatoreCodice",
        "methods": [
            "suggerisciMiglioramenti"
        ]
    },
    {
        "id": 113,
        "text": "// Esempio di suggerimenti\n        if (calcolaLunghezzaMediaRighe(codice) > 80) {\n            suggerimenti.add(\"Considera di ridurre la lunghezza media delle righe.\");\n        }\n        if (contaCommenti(codice) < 5) {\n            suggerimenti.add(\"Aggiungi più commenti per migliorare la leggibilità.\");\n        }\n        if (calcolaComplessitaCiclomatica(codice) > 10) {\n            suggerimenti.add(\"Riduci la complessità ciclomatica suddividendo il codice in metodi più piccoli.\");\n        }",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 112,
        "end_line": 112,
        "class": "IspezionatoreCodice",
        "methods": [
            "Chiamata a: add"
        ]
    },
    {
        "id": 114,
        "text": "suggerimenti.add(\"Riduci la complessità ciclomatica suddividendo il codice in metodi più piccoli.\");\n        }\n\n        return suggerimenti;\n    }",
        "source": "my_project/classi_java_custom\\IspezionatoreCodice.java",
        "type": "code",
        "start_line": 112,
        "end_line": 112,
        "class": "IspezionatoreCodice",
        "methods": [
            "Chiamata a: add"
        ]
    },
    {
        "id": 115,
        "text": "package classi_java_custom;\n\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class MetricheAgili {\n\n    /**\n     * Calcola il Velocity Score adattivo\n     * @param sprintData Dati storici degli sprint\n     * @param fattoreComplessità [1-5]\n     * @return Velocity predittivo con deviazione standard\n     */\n    public static double calcolaVelocityScore(List<Double> sprintData, int fattoreComplessità) {",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 1,
        "end_line": 16,
        "class": "MetricheAgili",
        "methods": [
            "calcolaVelocityScore"
        ]
    },
    {
        "id": 116,
        "text": "*/\n    public static double calcolaVelocityScore(List<Double> sprintData, int fattoreComplessità) {\n        if (sprintData == null || sprintData.isEmpty()) {\n            throw new IllegalArgumentException(\"I dati degli sprint non possono essere nulli o vuoti.\");\n        }\n\n        // Calcola la media dei dati storici degli sprint\n        double mediaVelocity = sprintData.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n\n        // Calcola la deviazione standard",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 16,
        "end_line": 26,
        "class": "MetricheAgili",
        "methods": [
            "calcolaVelocityScore"
        ]
    },
    {
        "id": 117,
        "text": "// Calcola la deviazione standard\n        double deviazioneStandard = Math.sqrt(sprintData.stream()\n                .mapToDouble(value -> Math.pow(value - mediaVelocity, 2))\n                .sum() / sprintData.size());\n\n        // Adatta il Velocity Score in base al fattore di complessità\n        double velocityScore = mediaVelocity * (1 + (fattoreComplessità - 3) * 0.1);\n\n        System.out.println(\"Velocity Score: \" + velocityScore);",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 26,
        "end_line": 39,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: println"
        ]
    },
    {
        "id": 118,
        "text": "System.out.println(\"Velocity Score: \" + velocityScore);\n        System.out.println(\"Deviazione Standard: \" + deviazioneStandard);\n\n        return velocityScore;\n    }\n\n    /**\n     * Genera il rapporto di maturità agile\n     * @param metriche Mappa di metriche chiave\n     * @return Rapporto strutturato in XML\n     */\n    public static String generaRapportoMaturita(Map<String, Double> metriche) {\n        try {\n            DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 39,
        "end_line": 50,
        "class": "MetricheAgili",
        "methods": [
            "generaRapportoMaturita"
        ]
    },
    {
        "id": 119,
        "text": "try {\n            DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder docBuilder = docFactory.newDocumentBuilder();\n\n            // Creazione del documento XML\n            Document doc = docBuilder.newDocument();\n            Element rootElement = doc.createElement(\"RapportoMaturitaAgile\");\n            doc.appendChild(rootElement);\n\n            // Aggiunta delle metriche al rapporto",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 50,
        "end_line": 57,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: appendChild"
        ]
    },
    {
        "id": 120,
        "text": "doc.appendChild(rootElement);\n\n            // Aggiunta delle metriche al rapporto\n            for (Map.Entry<String, Double> entry : metriche.entrySet()) {\n                Element metricaElement = doc.createElement(\"Metrica\");\n                metricaElement.setAttribute(\"nome\", entry.getKey());\n                metricaElement.setAttribute(\"valore\", entry.getValue().toString());\n                rootElement.appendChild(metricaElement);\n            }",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 57,
        "end_line": 66,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: appendChild"
        ]
    },
    {
        "id": 121,
        "text": "rootElement.appendChild(metricaElement);\n            }\n\n            // Trasformazione del documento XML in stringa\n            TransformerFactory transformerFactory = TransformerFactory.newInstance();\n            Transformer transformer = transformerFactory.newTransformer();\n            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n            DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(new StringWriter());",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 66,
        "end_line": 80,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: setOutputProperty"
        ]
    },
    {
        "id": 122,
        "text": "DOMSource source = new DOMSource(doc);\n            StreamResult result = new StreamResult(new StringWriter());\n            transformer.transform(source, result);\n\n            return result.getWriter().toString();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante la generazione del rapporto di maturità agile\", e);\n        }\n    }\n\n    /**\n     * Calcola il Lead Time medio\n     * @param leadTimes Lista dei tempi di lead\n     * @return Lead Time medio\n     */",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 80,
        "end_line": 93,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 123,
        "text": "* Calcola il Lead Time medio\n     * @param leadTimes Lista dei tempi di lead\n     * @return Lead Time medio\n     */\n    public static double calcolaLeadTimeMedio(List<Double> leadTimes) {\n        if (leadTimes == null || leadTimes.isEmpty()) {\n            throw new IllegalArgumentException(\"I tempi di lead non possono essere nulli o vuoti.\");\n        }\n\n        return leadTimes.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 93,
        "end_line": 100,
        "class": "MetricheAgili",
        "methods": [
            "calcolaLeadTimeMedio"
        ]
    },
    {
        "id": 124,
        "text": "}\n\n        return leadTimes.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n    }\n\n    /**\n     * Analizza la qualità del codice basata su metriche chiave\n     * @param metriche Mappa di metriche chiave\n     * @return Analisi della qualità del codice\n     */\n    public static String analizzaQualitaCodice(Map<String, Double> metriche) {\n        // Esempio di analisi basata su metriche chiave\n        double codeCoverage = metriche.getOrDefault(\"CodeCoverage\", 0.0);",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 100,
        "end_line": 109,
        "class": "MetricheAgili",
        "methods": [
            "analizzaQualitaCodice"
        ]
    },
    {
        "id": 125,
        "text": "double codeCoverage = metriche.getOrDefault(\"CodeCoverage\", 0.0);\n        double codeComplexity = metriche.getOrDefault(\"CodeComplexity\", 0.0);\n        double bugDensity = metriche.getOrDefault(\"BugDensity\", 0.0);\n\n        StringBuilder analisi = new StringBuilder();\n        analisi.append(\"Analisi della qualità del codice:\\n\");\n        analisi.append(\"Copertura del codice: \").append(codeCoverage).append(\"%\\n\");\n        analisi.append(\"Complessità del codice: \").append(codeComplexity).append(\"\\n\");",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 109,
        "end_line": 117,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: append"
        ]
    },
    {
        "id": 126,
        "text": "analisi.append(\"Complessità del codice: \").append(codeComplexity).append(\"\\n\");\n        analisi.append(\"Densità di bug: \").append(bugDensity).append(\" bug/KLOC\\n\");\n\n        if (codeCoverage < 80) {\n            analisi.append(\"Suggerimento: Aumentare la copertura del codice.\\n\");\n        }\n        if (codeComplexity > 10) {\n            analisi.append(\"Suggerimento: Ridurre la complessità del codice.\\n\");\n        }\n        if (bugDensity > 0.5) {",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 117,
        "end_line": 117,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: append"
        ]
    },
    {
        "id": 127,
        "text": "analisi.append(\"Suggerimento: Ridurre la complessità del codice.\\n\");\n        }\n        if (bugDensity > 0.5) {\n            analisi.append(\"Suggerimento: Ridurre la densità di bug.\\n\");\n        }\n\n        return analisi.toString();\n    }",
        "source": "my_project/classi_java_custom\\MetricheAgili.java",
        "type": "code",
        "start_line": 117,
        "end_line": 117,
        "class": "MetricheAgili",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 128,
        "text": "// 2. Classe per il calcolo delle metriche di progetto riservate\npackage classi_java_custom;\npublic class MetricheProgettoSegrete {\n    /**\n     * Calcola l'indice di maturità tecnologica (IMT) secondo i parametri aziendali\n     * @param complessita Valori [1-5] da matrice di valutazione interna\n     * @param technicalDebt Ore di debito tecnico\n     * @param coperturaTest Percentuale di test automatizzati\n     * @return Valore IMT normalizzato\n     */",
        "source": "my_project/classi_java_custom\\MetricheProgettoSegrete.java",
        "type": "code",
        "start_line": 1,
        "end_line": 10,
        "class": "MetricheProgettoSegrete",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 129,
        "text": "* @param coperturaTest Percentuale di test automatizzati\n     * @return Valore IMT normalizzato\n     */\n    public static double calcolaIMT(int[] complessita, int technicalDebt, double coperturaTest) {\n        if (complessita == null || complessita.length == 0) return 0.0;\n        \n        double complessitaMedia = 0;\n        for (int val : complessita) {\n            complessitaMedia += val;\n        }\n        complessitaMedia /= complessita.length;",
        "source": "my_project/classi_java_custom\\MetricheProgettoSegrete.java",
        "type": "code",
        "start_line": 10,
        "end_line": 21,
        "class": "MetricheProgettoSegrete",
        "methods": [
            "calcolaIMT"
        ]
    },
    {
        "id": 130,
        "text": "complessitaMedia += val;\n        }\n        complessitaMedia /= complessita.length;\n        \n        double normalizzatoDebitoTecnico = Math.max(0, 100 - technicalDebt) / 100.0;\n        double normalizzatoCopertura = coperturaTest / 100.0;\n        \n        return (0.5 * complessitaMedia + 0.3 * normalizzatoDebitoTecnico + 0.2 * normalizzatoCopertura);\n    }\n\n    /**\n     * Genera il codice di stato progetto secondo il formato aziendale\n     * @param imt Valore IMT calcolato",
        "source": "my_project/classi_java_custom\\MetricheProgettoSegrete.java",
        "type": "code",
        "start_line": 21,
        "end_line": 33,
        "class": "MetricheProgettoSegrete",
        "methods": [
            "Chiamata a: max"
        ]
    },
    {
        "id": 131,
        "text": "}\n\n    /**\n     * Genera il codice di stato progetto secondo il formato aziendale\n     * @param imt Valore IMT calcolato\n     * @param rischi Valutazione rischi da 1 a 10\n     * @return Codice di stato criptico (es: \"AX3-R9\")\n     */\n    public static String generaCodiceStato(double imt, int rischi) {\n        String[] prefissi = {\"AX\", \"BX\", \"CX\", \"DX\", \"EX\"};\n        int indicePrefisso = Math.min((int) (imt * prefissi.length), prefissi.length - 1);",
        "source": "my_project/classi_java_custom\\MetricheProgettoSegrete.java",
        "type": "code",
        "start_line": 33,
        "end_line": 40,
        "class": "MetricheProgettoSegrete",
        "methods": [
            "generaCodiceStato"
        ]
    },
    {
        "id": 132,
        "text": "int indicePrefisso = Math.min((int) (imt * prefissi.length), prefissi.length - 1);\n        \n        return String.format(\"%s%d-R%d\", prefissi[indicePrefisso], (int) (imt * 10), rischi);\n    }\n}",
        "source": "my_project/classi_java_custom\\MetricheProgettoSegrete.java",
        "type": "code",
        "start_line": 40,
        "end_line": 40,
        "class": "MetricheProgettoSegrete",
        "methods": [
            "Chiamata a: format"
        ]
    },
    {
        "id": 133,
        "text": "package classi_java_custom;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.stream.Collectors;\n\npublic class OrchestratoreTest {\n\n    /**\n     * Pianifica esecuzione test in base alla criticalità\n     * @param suiteTest Lista dei test disponibili\n     * @param priorita Mappa delle priorità\n     * @return Sequenza ottimizzata di esecuzione\n     */",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 1,
        "end_line": 16,
        "class": "OrchestratoreTest",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 134,
        "text": "* @param priorita Mappa delle priorità\n     * @return Sequenza ottimizzata di esecuzione\n     */\n    public static List<String> pianificaEsecuzioneTest(List<String> suiteTest, Map<String, Integer> priorita) {\n        // Ordina i test in base alla priorità\n        return suiteTest.stream()\n                .sorted(Comparator.comparingInt(test -> priorita.getOrDefault(test, 0)))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * Analizza la copertura del codice post-test",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 16,
        "end_line": 27,
        "class": "OrchestratoreTest",
        "methods": [
            "pianificaEsecuzioneTest"
        ]
    },
    {
        "id": 135,
        "text": ".collect(Collectors.toList());\n    }\n\n    /**\n     * Analizza la copertura del codice post-test\n     * @param risultatiTest Dettaglio esecuzione\n     * @param codiceSorgente Codice analizzato\n     * @return Report di copertura avanzato\n     */\n    public static String analizzaCopertura(List<TestResult> risultatiTest, String codiceSorgente) {\n        // Esempio di strumentazione code avanzato (simulato)\n        StringBuilder report = new StringBuilder();",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 27,
        "end_line": 37,
        "class": "OrchestratoreTest",
        "methods": [
            "analizzaCopertura"
        ]
    },
    {
        "id": 136,
        "text": "// Esempio di strumentazione code avanzato (simulato)\n        StringBuilder report = new StringBuilder();\n        report.append(\"Report di copertura avanzato:\\n\");\n\n        // Calcola la copertura del codice\n        int lineeTotali = codiceSorgente.split(\"\\n\").length;\n        int lineeCoperte = risultatiTest.stream()\n                .mapToInt(TestResult::getLineeCoperte)\n                .sum();\n\n        double coperturaPercentuale = (double) lineeCoperte / lineeTotali * 100;",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 37,
        "end_line": 49,
        "class": "OrchestratoreTest",
        "methods": [
            "Chiamata a: sum"
        ]
    },
    {
        "id": 137,
        "text": ".sum();\n\n        double coperturaPercentuale = (double) lineeCoperte / lineeTotali * 100;\n        report.append(\"Copertura del codice: \").append(coperturaPercentuale).append(\"%\\n\");\n\n        // Aggiungi dettagli sui test falliti\n        List<TestResult> testFalliti = risultatiTest.stream()\n                .filter(TestResult::isFailed)\n                .collect(Collectors.toList());\n\n        if (!testFalliti.isEmpty()) {\n            report.append(\"Test falliti:\\n\");",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 49,
        "end_line": 62,
        "class": "OrchestratoreTest",
        "methods": [
            "Chiamata a: append"
        ]
    },
    {
        "id": 138,
        "text": "if (!testFalliti.isEmpty()) {\n            report.append(\"Test falliti:\\n\");\n            for (TestResult test : testFalliti) {\n                report.append(\"Test: \").append(test.getNomeTest()).append(\" - Motivo: \").append(test.getMotivoFallimento()).append(\"\\n\");\n            }\n        } else {\n            report.append(\"Tutti i test sono passati con successo.\\n\");\n        }\n\n        return report.toString();\n    }\n\n    /**\n     * Genera un report dettagliato dei test",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 62,
        "end_line": 72,
        "class": "OrchestratoreTest",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 139,
        "text": "}\n\n        return report.toString();\n    }\n\n    /**\n     * Genera un report dettagliato dei test\n     * @param risultatiTest Dettaglio esecuzione\n     * @return Report dettagliato dei test\n     */\n    public static String generaReportTest(List<TestResult> risultatiTest) {\n        StringBuilder report = new StringBuilder();\n        report.append(\"Report dettagliato dei test:\\n\");\n\n        for (TestResult test : risultatiTest) {\n            report.append(\"Test: \").append(test.getNomeTest())",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 72,
        "end_line": 87,
        "class": "OrchestratoreTest",
        "methods": [
            "generaReportTest"
        ]
    },
    {
        "id": 140,
        "text": "for (TestResult test : risultatiTest) {\n            report.append(\"Test: \").append(test.getNomeTest())\n                    .append(\" - Stato: \").append(test.isFailed() ? \"Fallito\" : \"Passato\")\n                    .append(\" - Linee coperte: \").append(test.getLineeCoperte())\n                    .append(\"\\n\");\n        }\n\n        return report.toString();\n    }\n\n    /**\n     * Identifica i test falliti\n     * @param risultatiTest Dettaglio esecuzione\n     * @return Lista dei test falliti\n     */",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 87,
        "end_line": 92,
        "class": "OrchestratoreTest",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 141,
        "text": "* Identifica i test falliti\n     * @param risultatiTest Dettaglio esecuzione\n     * @return Lista dei test falliti\n     */\n    public static List<String> identificaTestFalliti(List<TestResult> risultatiTest) {\n        return risultatiTest.stream()\n                .filter(TestResult::isFailed)\n                .map(TestResult::getNomeTest)\n                .collect(Collectors.toList());\n    }\n}",
        "source": "my_project/classi_java_custom\\OrchestratoreTest.java",
        "type": "code",
        "start_line": 92,
        "end_line": 92,
        "class": "OrchestratoreTest",
        "methods": [
            "identificaTestFalliti"
        ]
    },
    {
        "id": 142,
        "text": "package classi_java_custom;\n\n\npublic class OttimizzatoreQuery {\n\n   /**\n     * Applica le regole di ottimizzazione del motore \"TurboSQL\"\n     * @param query Query SQL originale\n     * @param schema Struttura del database\n     * @return Query ottimizzata con hint speciali\n     */\n    public static String ottimizzaQuery(String query, String schema) {\n        // Esempio di ottimizzazione: aggiungere hint per l'uso di indici\n        String ottimizzata = query;",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 1,
        "end_line": 14,
        "class": "OttimizzatoreQuery",
        "methods": [
            "ottimizzaQuery"
        ]
    },
    {
        "id": 143,
        "text": "// Esempio di ottimizzazione: aggiungere hint per l'uso di indici\n        String ottimizzata = query;\n\n        // Riconoscimento di pattern per ottimizzare le query\n        Pattern selectPattern = Pattern.compile(\"(?i)SELECT\\\\s+.*?\\\\s+FROM\\\\s+(\\\\w+)\", Pattern.MULTILINE);\n        Matcher matcher = selectPattern.matcher(query);\n\n        while (matcher.find()) {\n            String tableName = matcher.group(1);\n            // Aggiungi hint per l'uso di indici",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 14,
        "end_line": 24,
        "class": "OttimizzatoreQuery",
        "methods": [
            "Chiamata a: group"
        ]
    },
    {
        "id": 144,
        "text": "String tableName = matcher.group(1);\n            // Aggiungi hint per l'uso di indici\n            String hint = \"/*+ INDEX(\" + tableName + \"_idx) */ \";\n            ottimizzata = ottimizzata.replaceFirst(\"FROM\\\\s+\" + tableName, \"FROM \" + hint + tableName);\n        }\n\n        // Altre ottimizzazioni possono essere aggiunte qui\n        return ottimizzata;\n    }\n\n    /**\n     * Calcola il punteggio di efficienza della query\n     * @param query Plan di esecuzione",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 24,
        "end_line": 37,
        "class": "OttimizzatoreQuery",
        "methods": [
            "Chiamata a: replaceFirst"
        ]
    },
    {
        "id": 145,
        "text": "}\n\n    /**\n     * Calcola il punteggio di efficienza della query\n     * @param query Plan di esecuzione\n     * @return Punteggio TQE (Total Query Efficiency)\n     */\n    public static double calcolaTQE(String query) {\n        // Esempio di calcolo del punteggio TQE basato su un modello di machine learning interno\n        // Supponiamo che il modello restituisca un punteggio tra 0 e 100\n        // Questo è un esempio semplificato; in pratica, si potrebbe usare un modello ML reale",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 37,
        "end_line": 47,
        "class": "OttimizzatoreQuery",
        "methods": [
            "calcolaTQE"
        ]
    },
    {
        "id": 146,
        "text": "// Questo è un esempio semplificato; in pratica, si potrebbe usare un modello ML reale\n\n        // Analisi del piano di esecuzione (simulato)\n        int numJoins = countOccurrences(query, \"JOIN\");\n        int numSubqueries = countOccurrences(query, \"SELECT\");\n        int numIndexHints = countOccurrences(query, \"INDEX\");\n\n        // Calcolo del punteggio TQE\n        double tqe = 100.0 - (numJoins * 5) - (numSubqueries * 3) + (numIndexHints * 7);\n        return Math.max(0, Math.min(100, tqe));\n    }",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 47,
        "end_line": 59,
        "class": "OttimizzatoreQuery",
        "methods": [
            "Chiamata a: min"
        ]
    },
    {
        "id": 147,
        "text": "return Math.max(0, Math.min(100, tqe));\n    }\n\n    /**\n     * Conta le occorrenze di una parola chiave nella query\n     * @param query Query SQL\n     * @param keyword Parola chiave da contare\n     * @return Numero di occorrenze\n     */\n    private static int countOccurrences(String query, String keyword) {\n        Pattern pattern = Pattern.compile(keyword, Pattern.CASE_INSENSITIVE);\n        Matcher matcher = pattern.matcher(query);\n        int count = 0;\n        while (matcher.find()) {",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 59,
        "end_line": 74,
        "class": "OttimizzatoreQuery",
        "methods": [
            "countOccurrences"
        ]
    },
    {
        "id": 148,
        "text": "Matcher matcher = pattern.matcher(query);\n        int count = 0;\n        while (matcher.find()) {\n            count++;\n        }\n        return count;\n    }\n\n    /**\n     * Suggerisce indici basati sull'analisi della query\n     * @param query Query SQL\n     * @return Suggerimenti per indici\n     */\n    public static String suggerisciIndici(String query) {\n        // Esempio di suggerimento di indici basato su pattern riconosciuti",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 74,
        "end_line": 87,
        "class": "OttimizzatoreQuery",
        "methods": [
            "suggerisciIndici"
        ]
    },
    {
        "id": 149,
        "text": "// Esempio di suggerimento di indici basato su pattern riconosciuti\n        Pattern selectPattern = Pattern.compile(\"(?i)SELECT\\\\s+.*?\\\\s+FROM\\\\s+(\\\\w+)\", Pattern.MULTILINE);\n        Matcher matcher = selectPattern.matcher(query);\n\n        StringBuilder suggerimenti = new StringBuilder();\n        while (matcher.find()) {\n            String tableName = matcher.group(1);\n            suggerimenti.append(\"Considera di aggiungere un indice su \").append(tableName).append(\".\\n\");\n        }",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 87,
        "end_line": 100,
        "class": "OttimizzatoreQuery",
        "methods": [
            "Chiamata a: append"
        ]
    },
    {
        "id": 150,
        "text": "suggerimenti.append(\"Considera di aggiungere un indice su \").append(tableName).append(\".\\n\");\n        }\n\n        return suggerimenti.toString();\n    }\n\n    /**\n     * Analizza la complessità della query\n     * @param query Query SQL\n     * @return Livello di complessità\n     */\n    public static String analizzaComplessita(String query) {\n        int numJoins = countOccurrences(query, \"JOIN\");\n        int numSubqueries = countOccurrences(query, \"SELECT\");",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 100,
        "end_line": 103,
        "class": "OttimizzatoreQuery",
        "methods": [
            "analizzaComplessita"
        ]
    },
    {
        "id": 151,
        "text": "int numJoins = countOccurrences(query, \"JOIN\");\n        int numSubqueries = countOccurrences(query, \"SELECT\");\n\n        if (numJoins > 5 || numSubqueries > 3) {\n            return \"Complessità elevata\";\n        } else if (numJoins > 2 || numSubqueries > 1) {\n            return \"Complessità media\";\n        } else {\n            return \"Complessità bassa\";\n        }\n    }\n}",
        "source": "my_project/classi_java_custom\\OttimizzatoreQuery.java",
        "type": "code",
        "start_line": 103,
        "end_line": 103,
        "class": "OttimizzatoreQuery",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 152,
        "text": "package classi_java_custom;\n\nimport java.util.List;\nimport java.util.Map;\nimport java.util.ArrayList;\nimport java.util.stream.Collectors;\n\npublic class SupervisorePerformance {\n\n    /**\n     * Calcola l'indice di salute del sistema (SHI)\n     * @param metriche Dati in tempo reale\n     * @return Valore SHI con trend\n     */\n    public static double calcolaSHI(Map<String, Double> metriche) {\n        // Esempio di calcolo dell'indice di salute del sistema (SHI)",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 1,
        "end_line": 16,
        "class": "SupervisorePerformance",
        "methods": [
            "calcolaSHI"
        ]
    },
    {
        "id": 153,
        "text": "// Esempio di calcolo dell'indice di salute del sistema (SHI)\n        double cpuUsage = metriche.getOrDefault(\"cpuUsage\", 0.0);\n        double memoryUsage = metriche.getOrDefault(\"memoryUsage\", 0.0);\n        double responseTime = metriche.getOrDefault(\"responseTime\", 0.0);\n        double errorRate = metriche.getOrDefault(\"errorRate\", 0.0);\n\n        // Formula pesata con coefficienti dinamici\n        double weightCpu = 0.4;\n        double weightMemory = 0.3;\n        double weightResponse = 0.2;",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 16,
        "end_line": 28,
        "class": "SupervisorePerformance",
        "methods": [
            "Chiamata a: getOrDefault"
        ]
    },
    {
        "id": 154,
        "text": "double weightCpu = 0.4;\n        double weightMemory = 0.3;\n        double weightResponse = 0.2;\n        double weightError = 0.1;\n\n        double shi = (cpuUsage * weightCpu) + (memoryUsage * weightMemory) +\n                     (responseTime * weightResponse) + (errorRate * weightError);\n\n        // Normalizza il valore SHI tra 0 e 100\n        shi = Math.max(0, Math.min(100, shi));\n\n        System.out.println(\"SHI: \" + shi);\n        return shi;\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 28,
        "end_line": 41,
        "class": "SupervisorePerformance",
        "methods": [
            "Chiamata a: println"
        ]
    },
    {
        "id": 155,
        "text": "shi = Math.max(0, Math.min(100, shi));\n\n        System.out.println(\"SHI: \" + shi);\n        return shi;\n    }\n\n    /**\n     * Genera allarmi predittivi basati su machine learning\n     * @param datiStorici Serie temporale di metriche\n     * @return Lista di allarmi con priorità\n     */\n    public static List<String> generaAllarmiPredittivi(List<Double> datiStorici) {\n        // Esempio di generazione di allarmi predittivi utilizzando un modello LSTM (simulato)",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 41,
        "end_line": 50,
        "class": "SupervisorePerformance",
        "methods": [
            "generaAllarmiPredittivi"
        ]
    },
    {
        "id": 156,
        "text": "// Esempio di generazione di allarmi predittivi utilizzando un modello LSTM (simulato)\n        List<String> allarmi = new ArrayList<>();\n\n        // Simulazione di un modello LSTM che prevede anomalie\n        for (int i = 0; i < datiStorici.size(); i++) {\n            double valore = datiStorici.get(i);\n            if (valore > 80) { // Soglia di allarme simulata\n                allarmi.add(\"Allarme: Valore anomalo rilevato al tempo \" + i);\n            }\n        }\n\n        return allarmi;\n    }",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 50,
        "end_line": 67,
        "class": "SupervisorePerformance",
        "methods": [
            "Chiamata a: add"
        ]
    },
    {
        "id": 157,
        "text": "}\n        }\n\n        return allarmi;\n    }\n\n    /**\n     * Analizza le anomalie nelle metriche\n     * @param metriche Dati in tempo reale\n     * @return Report delle anomalie rilevate\n     */\n    public static String analizzaAnomalie(Map<String, Double> metriche) {\n        StringBuilder report = new StringBuilder();\n        report.append(\"Report delle anomalie rilevate:\\n\");\n\n        if (metriche.getOrDefault(\"cpuUsage\", 0.0) > 90) {\n            report.append(\"Anomalia: CPU usage elevato.\\n\");",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 67,
        "end_line": 77,
        "class": "SupervisorePerformance",
        "methods": [
            "analizzaAnomalie"
        ]
    },
    {
        "id": 158,
        "text": "if (metriche.getOrDefault(\"cpuUsage\", 0.0) > 90) {\n            report.append(\"Anomalia: CPU usage elevato.\\n\");\n        }\n        if (metriche.getOrDefault(\"memoryUsage\", 0.0) > 85) {\n            report.append(\"Anomalia: Memory usage elevato.\\n\");\n        }\n        if (metriche.getOrDefault(\"responseTime\", 0.0) > 500) {\n            report.append(\"Anomalia: Response time elevato.\\n\");\n        }\n        if (metriche.getOrDefault(\"errorRate\", 0.0) > 5) {",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 77,
        "end_line": 93,
        "class": "SupervisorePerformance",
        "methods": [
            "Chiamata a: getOrDefault"
        ]
    },
    {
        "id": 159,
        "text": "}\n        if (metriche.getOrDefault(\"errorRate\", 0.0) > 5) {\n            report.append(\"Anomalia: Error rate elevato.\\n\");\n        }\n\n        return report.toString();\n    }\n\n    /**\n     * Visualizza i trend delle metriche\n     * @param datiStorici Serie temporale di metriche\n     * @return Visualizzazione dei trend\n     */\n    public static String visualizzaTrend(List<Double> datiStorici) {\n        StringBuilder trendReport = new StringBuilder();",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 93,
        "end_line": 104,
        "class": "SupervisorePerformance",
        "methods": [
            "visualizzaTrend"
        ]
    },
    {
        "id": 160,
        "text": "public static String visualizzaTrend(List<Double> datiStorici) {\n        StringBuilder trendReport = new StringBuilder();\n        trendReport.append(\"Trend delle metriche:\\n\");\n\n        // Esempio di visualizzazione dei trend (semplificato)\n        double media = datiStorici.stream().mapToDouble(Double::doubleValue).average().orElse(0.0);\n        trendReport.append(\"Media: \").append(media).append(\"\\n\");\n\n        double varianza = datiStorici.stream()",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 104,
        "end_line": 104,
        "class": "SupervisorePerformance",
        "methods": [
            "visualizzaTrend"
        ]
    },
    {
        "id": 161,
        "text": "trendReport.append(\"Media: \").append(media).append(\"\\n\");\n\n        double varianza = datiStorici.stream()\n                .mapToDouble(value -> Math.pow(value - media, 2))\n                .sum() / datiStorici.size();\n        trendReport.append(\"Varianza: \").append(varianza).append(\"\\n\");\n\n        return trendReport.toString();\n    }\n}",
        "source": "my_project/classi_java_custom\\SupervisorePerformance.java",
        "type": "code",
        "start_line": 104,
        "end_line": 104,
        "class": "SupervisorePerformance",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 162,
        "text": "package classi_java_custom;\n\nimport org.json.JSONObject;\nimport javax.crypto.Cipher;\nimport javax.crypto.KeyGenerator;\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Base64;\n\npublic class TrasformatoreDati {\n\n    private static final String ALGORITMO = \"AES\";\n\n    /**\n     * Applica la trasformazione \"ShadowMask\" ai dati sensibili\n     * @param dati Originali in formato JSON",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 1,
        "end_line": 17,
        "class": "TrasformatoreDati",
        "methods": [
            "unknown_method"
        ]
    },
    {
        "id": 163,
        "text": "/**\n     * Applica la trasformazione \"ShadowMask\" ai dati sensibili\n     * @param dati Originali in formato JSON\n     * @return Dati anonimizzati con preservazione formati\n     */\n    public static String applicaShadowMask(String dati) {\n        try {\n            // Genera una chiave segreta\n            KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITMO);\n            keyGen.init(128);\n            SecretKey chiaveSegreta = keyGen.generateKey();",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 17,
        "end_line": 28,
        "class": "TrasformatoreDati",
        "methods": [
            "applicaShadowMask"
        ]
    },
    {
        "id": 164,
        "text": "keyGen.init(128);\n            SecretKey chiaveSegreta = keyGen.generateKey();\n            String chiaveBase64 = Base64.getEncoder().encodeToString(chiaveSegreta.getEncoded());\n\n            // Cifra i dati\n            Cipher cipher = Cipher.getInstance(ALGORITMO);\n            cipher.init(Cipher.ENCRYPT_MODE, chiaveSegreta);\n            byte[] datiCifrati = cipher.doFinal(dati.getBytes(StandardCharsets.UTF_8));",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 28,
        "end_line": 35,
        "class": "TrasformatoreDati",
        "methods": [
            "Chiamata a: getBytes"
        ]
    },
    {
        "id": 165,
        "text": "byte[] datiCifrati = cipher.doFinal(dati.getBytes(StandardCharsets.UTF_8));\n            String datiCifratiBase64 = Base64.getEncoder().encodeToString(datiCifrati);\n\n            // Crea un JSON con i dati cifrati e la chiave\n            JSONObject json = new JSONObject();\n            json.put(\"dati\", datiCifratiBase64);\n            json.put(\"chiave\", chiaveBase64);\n\n            return json.toString();\n        } catch (Exception e) {",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 35,
        "end_line": 48,
        "class": "TrasformatoreDati",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 166,
        "text": "json.put(\"chiave\", chiaveBase64);\n\n            return json.toString();\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante l'applicazione della trasformazione ShadowMask\", e);\n        }\n    }\n\n    /**\n     * Inverte la trasformazione ShadowMask\n     * @param datiTrasformati Dati mascherati\n     * @param chiavePrivata Chiave di ri-identificazione\n     * @return Dati originali\n     */",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 48,
        "end_line": 59,
        "class": "TrasformatoreDati",
        "methods": [
            "Chiamata a: toString"
        ]
    },
    {
        "id": 167,
        "text": "* @param chiavePrivata Chiave di ri-identificazione\n     * @return Dati originali\n     */\n    public static String rimuoviShadowMask(String datiTrasformati, String chiavePrivata) {\n        try {\n            // Decodifica il JSON\n            JSONObject json = new JSONObject(datiTrasformati);\n            String datiCifratiBase64 = json.getString(\"dati\");\n            String chiaveBase64 = json.getString(\"chiave\");\n\n            // Decodifica la chiave",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 59,
        "end_line": 67,
        "class": "TrasformatoreDati",
        "methods": [
            "rimuoviShadowMask"
        ]
    },
    {
        "id": 168,
        "text": "String chiaveBase64 = json.getString(\"chiave\");\n\n            // Decodifica la chiave\n            byte[] chiaveDecodificata = Base64.getDecoder().decode(chiaveBase64);\n            SecretKey chiaveSegreta = new SecretKeySpec(chiaveDecodificata, 0, chiaveDecodificata.length, ALGORITMO);\n\n            // Decifra i dati\n            Cipher cipher = Cipher.getInstance(ALGORITMO);\n            cipher.init(Cipher.DECRYPT_MODE, chiaveSegreta);",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 67,
        "end_line": 79,
        "class": "TrasformatoreDati",
        "methods": [
            "Chiamata a: init"
        ]
    },
    {
        "id": 169,
        "text": "Cipher cipher = Cipher.getInstance(ALGORITMO);\n            cipher.init(Cipher.DECRYPT_MODE, chiaveSegreta);\n            byte[] datiDecifrati = cipher.doFinal(Base64.getDecoder().decode(datiCifratiBase64));\n\n            return new String(datiDecifrati, StandardCharsets.UTF_8);\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante l'inversione della trasformazione ShadowMask\", e);\n        }\n    }\n\n    /**",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 79,
        "end_line": 90,
        "class": "TrasformatoreDati",
        "methods": [
            "Chiamata a: decode"
        ]
    },
    {
        "id": 170,
        "text": "}\n    }\n\n    /**\n     * Genera una chiave privata per la trasformazione ShadowMask\n     * @return Chiave privata in formato Base64\n     */\n    public static String generaChiavePrivata() {\n        try {\n            KeyGenerator keyGen = KeyGenerator.getInstance(ALGORITMO);\n            keyGen.init(128);\n            SecretKey chiaveSegreta = keyGen.generateKey();\n            return Base64.getEncoder().encodeToString(chiaveSegreta.getEncoded());\n        } catch (Exception e) {",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 90,
        "end_line": 103,
        "class": "TrasformatoreDati",
        "methods": [
            "generaChiavePrivata"
        ]
    },
    {
        "id": 171,
        "text": "return Base64.getEncoder().encodeToString(chiaveSegreta.getEncoded());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Errore durante la generazione della chiave privata\", e);\n        }\n    }\n\n    /**\n     * Verifica l'integrità dei dati trasformati\n     * @param datiTrasformati Dati mascherati\n     * @param chiavePrivata Chiave di ri-identificazione\n     * @return True se i dati sono integri, altrimenti false\n     */",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 103,
        "end_line": 103,
        "class": "TrasformatoreDati",
        "methods": [
            "Chiamata a: getEncoded"
        ]
    },
    {
        "id": 172,
        "text": "* @param chiavePrivata Chiave di ri-identificazione\n     * @return True se i dati sono integri, altrimenti false\n     */\n    public static boolean verificaIntegrita(String datiTrasformati, String chiavePrivata) {\n        try {\n            // Prova a decifrare i dati\n            rimuoviShadowMask(datiTrasformati, chiavePrivata);\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }",
        "source": "my_project/classi_java_custom\\TrasformatoreDati.java",
        "type": "code",
        "start_line": 103,
        "end_line": 103,
        "class": "TrasformatoreDati",
        "methods": [
            "verificaIntegrita"
        ]
    }
]